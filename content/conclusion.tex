	Les principales contibutions de la thèse ont été exprimées dans les chapitres précédents. Ce dernier chapitre vise à fournir une synthèse des contributions développées dans ce document et à les remettre en relation, puis concluera ce document en proposant des perspectives de recherche à long terme liées aux travaux de cette thèse.

	\section{Résumé des contributions}

		Le premier chapitre de contribution a présenté un service de transfert de flot d'exécution unifié au sein du noyau Pip. Ce service est muni d'une preuve formelle de la propriété classique de Pip sur la préservation de l'isolation. Le service permet de gérer de manière unifiée les transferts explicites de flot d'exécution, les interruptions logicielles, les fautes, ainsi que les interruptions matérielles au travers de points d'entrées placés de manière opportune le long d'un fil d'exécution unique. Ce service de transfert de flot d'exécution, présenté dans ce chapitre pour l'architecture Intel x86, n'est cependant pas spécifique à cette architecture, et a notamment été implémenté sur l'architecture Armv7.
		Les modèles ayant permis la preuve de préservation de l'isolation initiale ont été enrichis tout au long de la thèse, décrivant de manière plus précise les comportements du service ; le chapitre décrit une ébauche détaillée de preuve de préservation de l'isolation sur les derniers modèles sur lesquels la preuve d'isolation n'a pas encore été établie.

		De plus, ces travaux viennent contribuer à la complétion de la preuve de préservation de l'isolation sur l'ensemble des services de Pip. Ils corroborent les résultats de la méthodologie de co-design de Pip, visant à fournir les services strictement nécessaires à un système fonctionnel tout en réduisant l'effort de preuve requis. L'utilisabilité du service est montré dans le second chapitre de contribution de ce document : l'ordonnanceur temps-réel utilise le service de transfert de flot d'exécution pour exécuter les \emph{jobs} élus par la fonction d'élection, et est réveillé par les interruptions d'horloge, aussi gérées par ce service.

		Le second chapitre de contribution a présenté les travaux qui ont mené l'implémentation d'un ordonnanceur \emph{Earliest Deadline First} pour des séquences arbitraires de \emph{jobs}, dont la fonction d'élection a été prouvée correcte formellement. Plus spécifiquement, il a été montré que l'implémentation exécutable de la fonction d'élection respecte la politique d'ordonnancement \emph{Earliest Deadline First}. L'ordonnanceur présenté s'exécute en espace utilisateur dans une partition de mémoire sur un système s'exécutant avec Pip. Ce chapitre a présenté les étapes de la preuve de correction de la fonction d'élection, puis a présenté l'interface du code vérifié avec le logiciel inclus dans la base de confiance de notre ordonnanceur. Le chapitre propose ensuite une discussion sur cette base de confiance en la comparant à celle de travaux connexes. À notre connaissance, cet ordonnanceur \emph{Earliest Deadline First} est le premier de la littérature dont l'implémentation est munie d'une preuve formelle de correction de sa fonction d'élection et pouvant ordonnancer une séquence arbitraire de \emph{jobs}.

		La preuve de correction de l'ordonnanceur a été menée selon la méthode de co-design usuelle de Pip, mais a cependant été conduite par raffinement, contrairement aux preuves précédentes de Pip qui ont été prouvée par la méthode directe. Ces travaux montrent que cette méthodologie est efficace pour mener des preuves sur d'autres propriétés que les propriétés classiques de Pip et qu'elle s'accomode d'autres méthodes de preuve, comme par exemple le raffinement. Ces travaux montrent aussi qu'il est possible de vérifier formellement du code s'exécutant en espace utilisateur avec la méthodologie de Pip.

		Le dernier chapitre de contribution a présenté une preuve de concept séparant les modèles d'isolation de Pip du code des services. Cette séparation permet de définir des modèles alternatifs permettant de raisonner sur d'autres propriétés que les propriétés d'isolation classiques de Pip. Cette séparation a été rendue possible par la définition de \emph{Modules} rendant explicite l'interface du code des services avec le reste de la TCB (telle que les types, l'état, et les primitives d'interaction avec l'état). Ce chapitre a aussi montré que cette séparation ne remet pas en question les fonctionnalités traditionnelles de Pip, telle que l'extraction de l'AST du code permettant de compiler Pip vers du C ou la preuve formelle de propriétés sur le code.

		Cette contribution permet d'élargir significativement les perspectives de recherche relatives à Pip, notamment celles concernant la preuve de propriétés alternatives sur le code des services. Le premier chapitre de contribution sur le service de transfert de flot d'exécution avait mentionné que les propriétés d'isolation n'étaient pas particulièrement pertinentes pour ce service. Ces travaux proposent une solution permettant d'établir des propriétés alternatives pertinentes, comme la preuve fonctionnelle du service.


	\section{Perspectives de recherche à long terme}

		\subsection{Logique de séparation}

		Une perspective de recherche qui pourrait porter ses fruits à long terme serait de remplacer la logique de Hoare classique dans les preuves de Pip par la logique de séparation. La logique de séparation est un système formel dérivé de la logique de Hoare permettant de raisonner de manière plus efficace sur les programmes utilisant des structures de données et manipulant des pointeurs \cite{separationlogic, seplogic}.
		En particulier, les propriétés définies avec la logique de séparation sont liées à un \emph{store} et une \emph{heap}. Le \emph{store} est représenté par une fonction associant les variables du programme à leur valeur, la \emph{heap} est représentée par une fonction partielle associant des adresses à des valeurs. Ainsi, les propriétés de la logique de séparation se présente de la manière suivante : $s, h \vDash P$ où $P$ représente une propriété quelconque, $s$ représente le \emph{store} lié à cette propriété et où $h$ représente la \emph{heap} associée à cette propriété.

		Les propriétés exprimées avec la logique de séparation sont munis des opérateurs classiques de la logique booléenne tels que $\neg, \lor, \land, \implies, \exists, \forall$, etc. mais sont aussi munis de nouveaux opérateurs spécifiques à la logique de séparation. 
		\begin{itemize}
			\item L'opérateur $emp$ permet de définir que la \emph{heap} est vide, comme par exemple dans la propriété $s, h \vDash emp$ ;
			\item L'opérateur $\mapsto$ permet de définir une unique association dans la \emph{heap}, comme par exemple dans la propriété $s, h \vDash \text{adresse} \mapsto \text{valeur}$ ;
			\item L'opérateur de conjonction de séparation $*$, comme par exemple dans la propriété $s, h \vDash P * Q$, permet de définir que la \emph{heap} peut être séparée en deux parties distinctes telle que l'une vérifie la propriété $Q$ en partie droite de l'opérateur et que l'autre vérifie la propriété $P$ en partie gauche de l'opérateur ;
			\item L'opérateur d'implication de séparation $-*$ (aussi appelé opérateur ``baguette magique''), comme par exemple dans la propriété suivante $s, h \vDash P~{-}{*}~Q$ permet de définir que pour toute \emph{heap} $h'$ disjointe de la \emph{heap} originale $h$, si $h'$ satisfait la propriété $P$ en partie gauche de l'opérateur alors l'union des deux \emph{heaps} $h \bigcup h'$ satisfait la propriété $Q$ en partie droite de l'opérateur.
		\end{itemize}

		La logique de séparation est munie des règles d'inférence de la logique de Hoare classique, mais ajoute néanmoins une règle d'inférence qui fait de cette logique un outil très puissant : la règle du cadre (\emph{frame rule dans la littérature}).

		$$ \{~P~\}~c~\{~Q~\}~\vdash~\{~P~*~R~\}~c~\{~Q~*~R~\}$$

		Cette règle permet de raisonner localement sur le code $c$. La règle peut être décrite de la manière suivante : si le code $c$ peut s'exécuter dans un état restreint satisfaisant les propriétés $P$ pour produire un état satisfaisant les propriétés $Q$, alors le code $c$ peut s'exécuter dans un état plus grand que $P$ auquel on aurait rajouté une portion d'état arbitraire $R$, et le code $c$ transforme l'état pour qu'il satisfasse les propriétés $Q$ sans altérer la portion d'état arbitraire $R$ rajoutée.

		La logique de séparation me semble propice à la preuve des propriétés d'isolation de Pip. Néanmoins, cette pensée n'est qu'une intuition et l'utilisation de la logique de séparation pour reprouver les propriétés d'isolation ne semble pas particulièrement valorisable. La preuve de propriétés supplémentaires grâce à la logique de séparation présenterait -- à mon humble avis -- un intérêt pour la communauté scientifique, en particulier grâce à la comparaison de l'effort de preuve relatif à l'usage de ces deux logiques. Cette comparaison apparaitrait significativement biaisée sur la preuve d'isolation, à cause de la preuve déjà établie au travers d'années de travaux. On pourrait argumenter que cette expérience a considérablement facilité l'établissement de la preuve d'isolation au travers de la logique de séparation, et que notre comparaison avec la logique de Hoare n'est pas recevable. C'est pourquoi l'utilisation de la logique de séparation me semble être une perspective de recherche à long terme, où le temps investi dans la compréhension et l'inclusion de cette logique dans Pip ne pourrait montrer ses fruits qu'au bout d'une longue période de recherche comparé aux perspectives développées dans les chapitres de contribution.

		\subsection{Ordonnancement Earliest Deadline First régi par les évènements}

		Une des pistes de recherche qui pourraient mener à une contribution conséquente serait une amélioration de la contribution présentée en chapitre 4 à propos de l'ordonnanceur. En effet, dans ce chapitre, nous décrivons un ordonnanceur préemptif temps réel muni d'une politique d'ordonnancement \emph{Earliest Deadline First}. La préemption est effectuée à chaque période de temps dont la durée est prédéfinie par le système et mise en application au travers de la programmation de l'horloge du système, qui déclenche une interruption à chaque signal de l'horloge. Cette manière de concevoir un ordonnanceur s'appelle le \emph{quantum-driven scheduling} : chaque \emph{job} est ordonnancé à un moment multiple de la période décrite par l'horloge du système.

		Cependant, cette méthode d'ordonnancement n'est pas idéale. En effet, le \emph{job} exécuté sera interrompu même si aucune nouvelle information n'est disponible pour l'ordonnanceur. Ainsi, dans ce cas, le système interromp le \emph{job} élu à la période précédente, recalcule -- avec les mêmes informations -- le nouveau \emph{job} à exécuter (qui sera donc le même job qu'à la période précédente), puis renvoie son résultat pour reprendre l'exécution du \emph{job} précédent. Par ailleurs, l'ordonnanceur n'est exécuté qu'en chaque début des périodes décrites par l'horloge du système. Ainsi, si de nouvelles informations arrivent en plein milieu de période, comme par exemple la terminaison du \emph{job} exécuté, alors cette information n'est traitée qu'au début de la prochaine période. Ceci engendre un délai de traitement des informations mises à disposition de l'ordonnanceur, gaspillant de précieux cycles d'exécution pour les \emph{jobs}.

		Une amélioration de l'ordonnancement consiste à ne pas interrompre le \emph{job} en train d'être exécuté si aucune nouvelle information n'est disponible pour l'ordonnanceur. En particulier, les interruptions liées à l'ordonnancement ne sont plus levées à chaque période d'horloge, mais sont levées lorsque de nouveaux \emph{jobs} sont prêts à être ordonnancés ou quand le \emph{job} exécuté a terminé son exécution. Cette méthode d'ordonnancement est nommée \emph{event-driven scheduling} et permet d'améliorer les performances de l'ordonnanceur \cite{brandenburg2009implementation}.

		Une telle amélioration est envisageable pour l'ordonnanceur présenté en chapitre 4, mais nécessite une réécriture de l'algorithme de la fonction d'élection ainsi qu'une adaptation de la preuve de correction, en particulier sur les propriétés relatives au temps. Pour ces dernières, le compteur de temps n'augmentait que d'une période à chaque nouvelle exécution de la fonction d'élection, ce qui ne sera plus vrai avec l'\emph{event-driven scheduling}.

		De plus, ces travaux présentent une opportunité d'étudier les performances de notre ordonnanceur. Ces résultats, couplés à la preuve formelle de correction de la fonction d'élection, sont susceptibles -- selon moi -- d'intéresser la communauté temps réel, au prix d'un effort de réécriture et de comparaison des résultats conséquents.
