% Here you introduce your topic to the reader.

\section{Contexte}

\subsection{Humain}

Cette thèse a été menée à l'Université de Lille, en collaboration avec le \emph{Centre de Recherche en Informatique, Signal et Automatique de Lille} (communement abrégé en laboratoire CRIStAL). Cette thèse a été financée par une dotation de l'Université de Lille.

Cette thèse a été dirigée par Gilles Grimaud, directeur de l'équipe <<~\emph{eXtra Small, eXtra Safe}~>> (abrégé 2XS) du CRIStAL. L'équipe se spécialise dans la conception de logiciels et matériels apportant sécurité, fiabilité et efficacité aux systèmes embarqués fortement contraints. Les travaux menés dans l'équipe portent sur la conception d'un noyau de système d'exploitation munis de preuves formelles de propriétés d'isolation de la mémoire, sur les moyens d'attaque physique sur du logiciel (Bluetooth, LoRa, analyse de la consommation, ...), sur la détection de malware et obfuscation d'applications Android, mais aussi sur des objets mathématiques plus théoriques comme par exemple les fonctions corécursives et leur représentation dans un assistant de preuve.

\emph{2XS} a des relations privilégiées avec d'autres équipes du laboratoire, notamment celles faisant partie du même groupe thématique <<~\emph{Systèmes embarqués adaptables et sécurisés}~>>. Cette thèse a notamment tiré profit d'une forte proximité avec l'équipe \emph{SyCoMoRES}, dont les travaux portent sur la conception et l’analyse des systèmes embarqués temps réel, basé sur l’analyse symbolique de composants paramétriques. La seconde contribution de cette thèse est le fruit de cette collaboration.

Par ailleurs, l'équipe \emph{2XS} est hébergée à l'\emph{Institut de Recherche sur les Composants logiciels et matériels pour l’Information et la Communication Avancée} (abrégé IRCICA). L'IRCICA est un établissement conçu pour favoriser la recherche interdisciplinaire, ce qui a notamment permis à l'équipe de saisir de nombreuses opportunités de collaboration avec l'\emph{Institut d'Électronique, de Microélectronique et de Nanotechnologies} (abrégé laboratoire IEMN), et plus particulièrement avec le groupe de recherche \emph{CSAM} notamment sur les travaux relatifs à l'attaque de logiciel au travers de moyens physiques.

Les travaux présentés dans cette thèse sont liés au noyau de système d'exploitation nommé Pip développé dans l'équipe \emph{2XS}.

\subsection{Pip}

Pip est un noyau de système d'exploitation \emph{minimal} dont le seul but est de garantir l'isolation d'applications s'exécutant sur le système. Pour ce faire, Pip est muni de preuves formelles que ses services préservent les propriétés d'isolation lors de leur exécution. Pip utilise la mémoire virtuelle comme moyen de garantir ces propriétés.

Le projet Pip a démarré avec trois thèses fondatrices :
\begin{itemize}
	\item La thèse de Narjes Jomaa, soutenue en décembre 2018, a porté sur l'aspect formel du noyau. Narjes a développé une méthodologie permettant de raisonner sur le code des services de Pip, ainsi qu'une méthodologie de co-design du code des services avec les preuves formelles afin d'alléger l'effort de preuve global. Narjes est à l'origine des preuves de préservation de l'isolation fournies par Pip ;
	\item La thèse de Quentin Bergougnoux, soutenue en juin 2019, a porté sur l'implémentation du noyau sur l'architecture Intel x86, en particulier sur le code des services actuellement présents dans le noyau. Ses travaux ont aussi porté sur des preuves de concept explorant les possibilités de portage de Pip sur un environnement multicœur ;
	\item La thèse de Mahiedinne Yaker, soutenue en décembre 2019, a porté sur l'implémentation de Pip sur une plateforme embarquée basée sur l'architecture Intel, offrant des perspectives de travail sur les systèmes embarqués. Ces travaux ont aussi portés sur des réflexions autour de la conception de systèmes où les entités y demeurant ne se font pas mutuellement confiance.
\end{itemize}

De ces travaux fondateurs ont émergé de nouvelles opportunités de recherche, dont certains se sont transformés en sujets de thèse. Trois nouvelles thèses ont été pourvues, portant sur des sujets étendants les travaux fondateurs :
\begin{itemize}
	\item La thèse de Nicolas Dejon, soutenue en décembre 2022, qui porte sur l'application des propriétés d'isolation de Pip aux systèmes dépourvus de mémoire virtuelle, mais pouvant restreindre l'accès à certaines portions de mémoire grâce à une \emph{MPU}. Ces caractéristiques sont courantes sur des systèmes beaucoup plus modestes, et se prêtent particulièrement bien à de l'\emph{IoT} ;
	\item Les travaux initiaux de Sofia Santiago Fernandez qui portent sur la preuve de préservation de la sémantique du code des services lors de la compilation du code Gallina \emph{shallow-embedded} vers du code C ;
	\item Mes propres travaux de thèse, présentés dans ce document, portant sur la formalisation du transfert de flôt d'exécution au sein du noyau et de travaux préliminaires relatifs à l'ajout de nouvelles propriétés non relatives à l'isolation.
\end{itemize}

Les doctorants n'ont pas été les seules personnes recrutées pour participer au développement de Pip : c'est par exemple le cas de Damien Amara, recruté en tant qu'ingénieur de recherche. Damien a contribué de manière significative à l'implémentation de Pip sur l'architecture Armv7, ainsi qu'à la version de Pip pour les systèmes munis d'une \emph{MPU}. Pip a aussi été au cœur de nombreuses collaborations industrielles avec Orange. Il a été principalement financé par le projet européen Celtic+ ODSI, puis par le projet ANR franco-allemand TinyPART.

\section{Objets d'étude}

Cette thèse est développée autour de trois objets d'études principaux qui transparaissent dans l'état de l'art et les chapitres de contribution.

\subsection{Ordonnancement}

Un des objets d'étude de cette thèse est l'ordonnancement. Dans un système où des entités ont besoin de ressources pour accomplir certaines actions et où les ressources disponibles sont limitées, l'ordonnancement est le fait d'arbitrer quelles entités disposeront d'un accès aux ressources ainsi que les périodes à laquelle elles en disposeront. Le logiciel réalisant l'ordonnancement au sein d'un système est appelé l'ordonnanceur. Le processus d'ordonnancement est omniprésent dans nos ordinateurs modernes, par exemple lorsqu'ils doivent choisir -- plusieurs centaines de fois par seconde -- le prochain programme à exécuter parmi la centaine de programmes attendant leur tour. Cette décision est orientée par la politique d'ordonnancement qui dicte à l'ordonnanceur selon quels critères distribuer les ressources. Certaines politiques s'attachent plus particulièrement au respect de contraintes temporelles : on parle alors de politique d'ordonnancement temps réel.

\subsection{Transfert de flot d'exécution}

Un autre objet d'étude connexe dont il sera abondamment question dans ce document est le transfert de flôt d'exécution. La notion de transfert de flot d'execution est similaire à celle de la commutation de contexte. Lorsqu'un programme est interrompu et qu'un autre s'exécute à sa place, par exemple sous l'effet de l'ordonnancement des programmes du système, il se déroule un transfert de flot d'exécution. Le système se charge de sauvegarder tous les paramètres qui permettront de restaurer le programme interrompu comme s'il n'avait jamais été interrompu, puis charge le programme qui continuera son exécution.

Ce mécanisme et le processus d'ordonnancement au sein d'un système permettent d'exécuter de multiples programmes de manière concurrente et efficace. Ils sont notamment à l'oeuvre lorsque vous travaillez avec de nombreux logiciels simultanément sur votre ordinateur, lorsque vous visionnez une vidéo sur votre téléphone, ou lorsque vous prenez l'avion et qu'il navigue en pilote automatique.

\subsection{Preuve de programmes}

Le dernier objet d'étude principal, omniprésent dans ce document, est la preuve de programmes. La preuve de programmes est une technique permettant d'apporter de très fortes garanties sur le fonctionnement du programme étudié par le biais de démonstrations mathématiques. Apporter de telles garanties sur un programme est néanmoins \emph{extrêmement} coûteux, et n'est généralement entrepris que pour les systèmes dont un dysfonctionnement logiciel pourrait mettre en péril des vies humaines, ou pourrait engendrer la perte d'une quantité astronomique d'argent. De tels systèmes sont courants dans certains secteurs d'activités tels que l'aérospatial ou le transport.

\section{Présentation du document}

\subsection{Plan}

\textcolor{red}{FUTUR !}

La lecture de ce document a été découpée en 6 chapitres principaux. Le premier chapitre, que vous êtes en train de lire, est un chapitre d'introduction proposant une mise en contexte des travaux de thèses ainsi qu'une brève introduction aux objets d'étude principaux. Ce chapitre se termine par une exposition du plan et propose différents axes de lecture en fonction des sujets d'intérêts du lecteur.

Le second chapitre fait un état de l'art des sujets abordés dans cette thèse. Cet état de l'art se contente de décrire les notions nécessaires à la compréhension des travaux de thèse. Il est décomposé en trois parties, qui reflètent les objets d'étude principaux. La première partie de l'état de l'art concerne les transferts de flot d'exécution. Elle en donnera une définition qui les classifiera et décrira ses implications en terme de logiciel et de sécurité, plus particulièrement au travers du prisme de l'architecture Intel x86. La seconde partie de l'état de l'art, plus modeste, sera dédiée à l'ordonnancement. Elle en fera une présentation générale, discutera des politiques d'ordonnancement en proposant des métriques pour les évaluer, puis discutera plus particulièrement des systèmes temps réel, dont elle développera juste la théorie nécessaire à la compréhension des travaux de cette thèse. Cet état de l'art s'achève sur une partie concernant la preuve de programmes. L'état de l'art sur cette partie commencera par décrire le processus de raisonnement mathématique dans sa généralité, axée sur la vérification automatique du raisonnement grâce aux assistants de preuve, en prenant l'exemple de l'assistant de preuve Coq. Dans un second temps, cette partie décrira les méthodes particulières permettant de raisonner sur des programmes, puis concluera sur les exemples les plus probants de l'application de ces techniques sur des systèmes d'exploitation.

Le troisième chapitre présente la première contribution décrite dans cette thèse, un service de transfert de flot d'exécution unifié au sein du noyau Pip. Le chapitre commence par donner quelques motivations à l'écriture de ce nouveau service. Il décrit ensuite les idées derrière le service puis en décrit l'implémentation détaillée au sein de l'architecture Intel x86, en montrant comment les différents transferts de flot d'exécution ont été unifiés. Le chapitre se poursuit sur l'établissement de la preuve d'isolation traditionnelle de Pip sur ce service en décrivant les ajouts à l'interface avec la monade et détaillant fortement certaines portions du raisonnement, points clés de la preuve complète. Ce chapitre se terminera sur une courte section de retours d'expérience, proposant certaines métriques à propos de ce service et proposant des réflexions sur le résultat produit. 

Le quatrième chapitre présente la seconde contribution de cette thèse, un ordonnanceur \emph{Earliest Deadline First} implémenté en espace utilisateur et s'exécutant sur le noyau Pip dont la correction de la fonction d'élection a été formellement prouvée. Le chapitre donne d'abord une vue d'ensemble de l'ordonnanceur, décrivant la fonction d'élection et sa place au sein de l'ordonnanceur, et décrivant les composants internes de l'ordonnanceur. La section suivante décrit la preuve formelle de correction de la fonction d'élection, décrivant les différentes étapes du raffinement et les hypothèses utilisées. Le chapitre continue sur l'implémentation exécutable de l'ordonnanceur, et des problèmes de distortion entre les modèles et l'implementation. Ce chapitre se termine sur une section de prise de recul, discutant en particulier de la base de confiance des travaux présentés dans ce chapitre et dans les travaux de l'état de l'art.

Le cinquième chapitre présente la dernière contribution de cette thèse, une preuve de concept sur le noyau Pip, séparant la définition des modèles du code des services. Ce chapitre est conçu autour d'une portion de code des services, sur laquelle tous les aspects de Pip seront déclinés. Ce chapitre présentera en premier lieu les motivations de cette contribution de manière brève. Il présentera ensuite l'architecture monolithique actuelle de Pip, décrivant toutes les dépendances du code avec les modèles d'isolation, puis décrivant le processus de preuve actuel. Dans la section suivante est décrite la preuve de concept de ce chapitre. Elle commence par donner une vue d'ensemble de la preuve de concept et des changements apportés au noyau. Cette section décrit ensuite plus en détail chaque nouvel élément introduit par la preuve de concept, la manière d'extraire l'\emph{AST} du code des services et la méthode de preuve du code des services avec cette preuve de concept. Le chapitre se termine sur les perspectives de recherche apportées par cette contribution.

Le dernier chapitre résumera les trois contributions décrites dans ce document, en rappelant ce qui a été établi et les limites des travaux. Ce document s'achèvera sur les perspectives de recherche à beaucoup plus long terme. Les dernières pages du document contiennent la bibliographie et les annexes.

\subsection{Axes de lecture}

Cette section tâchera d'aiguiller votre lecture sur les parties du document susceptibles de vous intéresser.

Si vous souhaitez plutôt lire les parties du document dédiées aux aspects systèmes du transfert de flôt d'exécution et de l'ordonnancement, je vous invite à lire les sections \ref{control_flow_transfer} et \ref{sec:scheduling_sota} de l'état de l'art. Votre lecture peut se poursuivre dans le chapitre 3 décrivant le service de transfert de flot d'execution de Pip, et plus particulièrement la section \ref{sec:service_desc} décrivant de manière détaillée l'implémentation unifiée des différents transferts de flot d'exécution. Enfin, vous pourrez achever votre lecture dans le chapitre 4 décrivant l'ordonnanceur \emph{Earliest Deadline First}, en lisant les sections \ref{sec:sched_struct_desc} qui donne une vision globale des composants de l'ordonnanceur ainsi que la section \ref{sec:sched_impl} qui décrit l'implémentation de ces composants.

Si vous êtes plutôt intéressés par la méthodologie relative à la preuve formelle de propriétés sur du code source, je vous invite à lire la section \ref{sec:proof_sota} de l'état de l'art, qui traite de l'application de méthodes formelles sur du code source. Vous pourrez ensuite lire la section \ref{sec:proof} du chapitre 4, qui traite de la méthode de preuve de la fonction d'élection de l'ordonnanceur par raffinement. Vous pourrez terminer votre lecture sur le chapitre 5, qui propose une solution modularisant les modèles au sein du noyau Pip, permettant de créer de nombreux modèles pour les mêmes services.

Si vous êtes plutôt intéressés par les détails de la conduite d'une preuve formelle sur du code, je vous invite à lire aussi la section \ref{sec:proof_sota} de l'état de l'art, qui traite de la mécanique de raisonnement formel sur du code source, puis la section \ref{sec:service_proof_establish} du chapitre 3, qui présente les détails d'une portion de la preuve formelle nécessaire à l'établissement de la propriété de préservation de l'isolation de Pip sur le code du service de tranfert de flot d'exécution. Le chapitre 4 et le description de l'établissement de la preuve en section \ref{sec:proof} pourrait se révéler une lecture intéressante, bien que moins portées sur les détails de l'établissemrnt de la preuve.
