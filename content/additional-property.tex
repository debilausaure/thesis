\chapter{Ajout incrémental de propriétés sur le code prouvé}

	La section de discussion du premier chapitre a mis en avant le fait que l'ensemble de Pip était conçu autour des propriétés d'isolation à prouver. Le modèle des fonctions de l'interface et de l'état, jusqu'à la monade intégrée au code, sont liés aux propriétés d'isolation. Cette forte proximité est une conséquence de la philosophie de conception minimaliste de Pip, qui nous a poussé à ne définir que les éléments strictement nécessaires à l'établissement de le preuve de préservation de l'isolation. Cette approche nous a permis de minimiser l'effort de preuve pour la propriété d'isolation, mais présente un désavantage majeur : le code des services de Pip n'est pas indépendant des modèles sur lesquels il repose.

	Ainsi, il n'existe qu'un modèle unique dans Pip qui ne peut évoluer que de manière itérative. Chaque évolution rend caduques les propriétés établies sur l'ancien modèle, et implique de produire une nouvelle preuve des mêmes propriétés avec le nouveau modèle. Le moindre ajout de chaque itération rendant de plus en plus difficile l'établissement la preuve à produire.
	Ceci est un frein considérable à la vérification de nouvelles propriétés sur le code de Pip, telle que la preuve fonctionnelle du service présenté dans le premier chapitre. Si les nouvelles propriétés impliquent des changements trop importants sur le modèle, l'effort de preuve à fournir deviendrait inatteignable après seulement quelques itérations.

	Dans ce chapitre, nous présentons une preuve de concept d'abstraction des
	\section{Motivations}
		\subsection{Généraliser / modulariser la méthodologie de preuve de Pip}

		\subsection{Raisonner sur le lien entre le Yield et la fonction d'élection}
		% Description informelle des propriétés
	

	\section{Architecture monolithique}

		Cette section décrira de manière synthétique les composants actuels de Pip, en essayant de décrire leurs dépendances d'un point de vue logiciel. Elle commencera par donner brièvement une vue d'ensemble du projet. Puis, dans une première partie, elle décrira les dépendances du code des services sur les modèles décrits dans Pip. Elle dépliera les définitions pour mettre en lumière les dépendances qui existent entre les modèles des différents composants. Ensuite, dans une seconde partie, la section se penchera sur la méthode de preuve nécessaire à l'établissement de la preuve d'isolation. La section se concluera sur le processus de compilation du code, compilant le code des services de Gallina vers du code C.
		
		\subsection{Vue générale}

			\begin{figure}[!ht]
				\input{figures/current_pip_architecture.tex}
				\caption{Architecture actuelle de Pip et dépendances des composants}
				\label{fig:switchContextCont}
			\end{figure}
			\begin{listing}[!ht]
				\coqcode{code/switchContextCont.v}
				\caption{Code du bloc de continuation \texttt{switchContextCont} du service de transfert de flot d'exécution}
				\label{code:switchContextCont}
			\end{listing}

		\subsection{Dépendance du code au modèle d'isolation}

			\subsubsection{Monade dépendante du modèle de l'état}

			Dans l'architecture actuelle de Pip, le code des services repose directement sur les définitions de la monade, en utilisant le type monadique \texttt{LLI}, et les fonctions \texttt{bind} et \texttt{ret} pour représenter la mise en séquence des instructions des services. Dans l'exemple présenté en listing \ref{code:switchContextCont}, la fonction retourne un type monadique \texttt{LLI yield\_checks}, utilise la fonction \texttt{bind} au travers du sucre syntaxique \texttt{perform [...] := [...] ;}, et indique sa valeur de retour grâce à la fonction \texttt{ret}.
			Malheureusement, le type monadique \texttt{LLI}, décrit en listing \ref{code:LLImonad}, dépend de l'état \texttt{state}, décrit en listing \ref{code:CurrentIsolationState}. \texttt{state} est le modèle de l'état conçu pour la preuve de préservation de l'isolation. Ceci est une preière dépendance du code au modèle d'isolation.

		\begin{listing}[!ht]
			\coqcode{code/LLIMonad.v}
			\caption{Définition du type de la monade d'état \texttt{LLI} dans le modèle actuel de Pip}
			\label{code:LLImonad}
		\end{listing}

		\begin{listing}[!ht]
			\coqcode{code/CurrentIsolationState.v}
			\caption{Définition de l'état \texttt{state} dans le modèle actuel de Pip}
			\label{code:CurrentIsolationState}
		\end{listing}

			\subsubsection{Code dépendant des modèles des types}
		
		Ensuite, le modèle de l'état ainsi que le code des différents services dépend des types décrits par le modèle actuel de Pip.

		\begin{listing}[!ht]
			\coqcode{code/CurrentTypesModel.v}
			\caption{Définition des types nécessaires à la fonction \texttt{switchContextCont} dans le modèle actuel de Pip}
			\label{code:CurrentTypesModel}
		\end{listing}

		Enfin, le code intéragit avec l'état au travers de fonctions dont le modèle est lié au modèle de l'état et au modèle des types.

		\begin{listing}[!ht]
			\coqcode{code/CurrentFunctionsModel.v}
			\caption{Définition des fonctions de l'interface avec l'état nécessaire à la fonction \texttt{switchContextCont} dans le modèle actuel de Pip}
			\label{code:CurrentFunctionsModel}
		\end{listing}

		\subsection{Processus de preuve sur le code dépendant du modèle}

			\subsubsection{Définition des fonctions nécessaires à l'écriture de propriétés}

			\subsubsection{Définition des propriétés à prouver}

			\subsubsection{Définition des \emph{Weakest Preconditions} et des invariants}

		\subsection{Extraction de code}

		
	\section{Abstraction des modèles dans le code prouvé}

		\subsection{Définition de code générique indépendant des modèles}

			\subsubsection{Vue générale}

			\subsubsection{Abstraction du modèle types utilisés par Pip}

			\begin{listing}[!ht]
				\coqcode{code/TypesParameters.v}
				\caption{Définition de l'interface des types nécessaires à la fonction \texttt{switchContextCont}}
				\label{code:TypesParameter}
			\end{listing}

			\subsubsection{Abstraction du modèle de l'état}

			\begin{listing}[!ht]
				\coqcode{code/StateModel.v}
				\caption{Définition de l'interface de l'état}
				\label{code:StateParameter}
			\end{listing}

			\subsubsection{Définition d'une monade d'état agnostique du modèle de l'état}

			\begin{listing}[!ht]
				\coqcode{code/StateAgnosticMonad.v}
				\caption{Définition de la monade d'état}
				\label{code:StateAgnosticMonad}
			\end{listing}

			\subsubsection{Abstraction du modèle des fonctions de l'interface avec l'état}

			\begin{listing}[!ht]
				\coqcode{code/InterfaceParameters.v}
				\caption{Définition de l'interface des la monade d'état}
				\label{code:InterfaceParameters}
			\end{listing}

			\subsubsection{Code agnostique des modèles}

			\begin{listing}[!ht]
				\coqcode{code/ModelAgnosticCode.v}
				\caption{Définition du code affranchi de toute dépendance aux modèles}
				\label{code:ModelAgnosticCode}
			\end{listing}

		\subsection{Définition du modèle d'isolation s'interfaçant avec le code générique}
			\subsubsection{Définition du modèle des types du modèle de l'isolation}

			\subsubsection{Définition du modèle de l'état du modèle d'isolation}

			\subsubsection{Instanciation de la monade d'état relative au modèle d'isolation}

			\subsubsection{Définition du modèle des fonctions de l'interface avec l'état}

		\subsection{Méthode de preuve sur le code générique}
		% Instantiation de la monade pour raisonner sur les propriétés à prouver

		\subsection{Extraction de code}

	%\section{Illustration sur la fonction Yield de Pip}
	%	% Preuve fonctionnelle de Yield
	%	\subsection{Définition des propriétés de bon fonctionnement du Yield}
	%	\subsection{Modélisation de l'état nécessaire au bon fonctionnement de Yield}
	%	\subsection{Sketch of proof / Déroulé de la preuve}

	\section{Perspectives de recherche et discussion}
		\subsection{Établissement d'un modèle alternatif permettant de prouver les propriétés fonctionnelles du service de transfert de flôt d'exécution}
		\subsection{Lien entre la preuve de bon fonctionnement et le back end de l'ordonnanceur}
		\subsection{Discussion de la méthodologie}
			% Conduire les deux preuves indépendamment est différent de conduire deux preuves l'une après l'autre (en oubliant la première)
			% Lever les interrogations 
				% - preuve en meme temps aide à débusquer les incohérences / simplifications abusives
				% - mais trop complexe : explosion des termes -> trop couteux
