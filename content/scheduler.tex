\chapter{Politique d'ordonnancement prouvée}

	Le chapitre précédent a porté sur un service de transfert de flôt d'exécution au sein de Pip. Ce service permet de gérer les transferts explicites de flôt d'exécution, ainsi que les interruptions. De cette manière, Pip fournit les outils nécessaires à la préemption de flôts d'exécution. La préemption est nécessaire à la mise en place d'ordonnancement au sein d'un système ; elle n'est cependant pas suffisante pour implémenter un ordonnanceur. Celui-ci doit être muni d'une politique d'ordonnancement, lui permettant de choisir le prochain flôt d'exécution.

	Ce chapitre porte sur l'implémentation d'un ordonnanceur Earliest Deadline First (abrégé EDF) s'exécutant en espace utilisateur. L'ordonnanceur est conçu pour fonctionner dans une partition de Pip, et est muni d'une preuve formelle que sa fonction d'élection respecte la politique d'ordonnancement EDF. Ces travaux ont été menés conjointement avec Vlad Rusu, avec qui j'ai conçu les modèles sur lesquels reposent la preuve et qui a établit les preuves formelles sur cet ordonnanceur. Dans ce travail commun, ma contribution a été de concevoir les composants de l'ordonnanceur, leur interface ainsi qu'une partie de leur modèle, ainsi que d'écrire l'implémentation pour que cet ordonnanceur puisse être compilé et s'exécuter dans une partition de Pip.
	\footnote{David Nowak, Gilles Grimaud et Samuel Hym ont aussi contribué à ce projet de manière plus modeste. David a participé à l'élaboration des modèles, Gilles a participé à l'établissement des interfaces, et Samuel a participé à l'écriture de l'implémentation}.
	
	Ces travaux ont fait l'objet d'une publication et d'une présentation à RTAS2022, dont ce chapitre s'inspire fortement. Le papier est disponible à l'adresse suivante : \url{https://hal.archives-ouvertes.fr/hal-03671598}. La vidéo de la présentation est disponible à l'adresse suivante : \url{https://pip.univ-lille.fr/recordings/RTAS.mp4}. Le dépot contenant le code ainsi que les instructions pour exécuter l'ordonnanceur est hébergé sur Github : \url{https://github.com/2xs/pip_edf_scheduler}.

	\section{Motivations}
	
	% Autre type de preuve : garantir le respect des échéances / pourquoi est ce vraiment critique ?
	La motivation première de cette contribution est de proposer des garanties supplémentaires aux garanties d'isolation classiques de Pip. Cette motivation nous a mené à nous intéresser aux problématiques des systèmes temps réel, et notamment sur le respect des échéances, car nous pensons que la vision de Pip peut être pertinente. La preuve formelle du respect de la politique d'ordonnancement est un premier pas vers des garanties temps réel dans l'écosystème de Pip.

	% Intro : ce qu'on va étudier : utliser notre méthode de dévelopement de logiciel pour prouver un algorithme de selection des cibles du transfert de flot d'exécution autres propriétés que l'isolation
	Cette contribution est aussi un moyen d'éprouver la méthode de développement des logiciels et preuves de Pip, en l'appliquant à un autre objet d'étude. On peut noter deux différences fondamentales entre Pip et cet ordonnanceur. La première est que Pip s'exécute en mode privilégié, contrairement à l'ordonnanceur qui s'exécute en espace utilisateur. Cette différence a des répercussions sur la conception des interfaces ; la dépendance à du code non prouvé est moins critique en espace utilisateur. Cette différence a aussi un impact implicite sur les preuves : la logique de Hoare n'est valable que lorsque l'état ne change pas entre deux instructions -- il faut donc s'assurer que les interruptions ne perturbent pas l'ordonnanceur. La seconde réside dans le fait que les propriétés prouvées sur l'ordonnanceur relèvent de l'ordre des propriétés fonctionnelles, c'est à dire qui décrivent le comportement de l'ordonnanceur. Les propriétés d'isolation de Pip traditionnellement prouvées au travers de cette méthode ne sont pas des propriétés fonctionnelles. Aussi, nous ne chercherons pas à établir des propriétés non-fonctionnelles sur la préemption telles que des propriétés sur le partage du temps d'exécution du processeur. Ces deux différences font de cet ordonnanceur un objet d'étude intéressant du point de vue du développement logiciel.

	De plus, cette contribution utilise tous les aspects du service de transfert de flôt d'exécution décrit dans le chapitre précédent. Cette contribution permet d'exhiber par l'expérience que l'utilisation de ce service est pertinente dans un composant commun de système d'exploitation.
	
	Enfin, cette contribution apporte une preuve inédite à la communauté des systèmes temps réels. En effet, les travaux montrant de manière formelle des propriétés sur les algorithmes d'ordonnancement sont fréquents dans la communauté. Néanmoins, peu de travaux s'intéressent à la preuve de \emph{l'implémentation} de l'algorithme, qui permettent par exemple de propager les preuves jusqu'au code compilé, et qui tiennent compte de détails supplémentaires (tels que les structures de données par exemple). Cette contribution fournit une preuve formelle que l'implémentation de la fonction d'élection respecte la politique d'ordonnancement EDF pour des \emph{jobs} arbitraires, ce qui n'avait été prouvé sur aucun autre ordonnanceur EDF auparavant. Des travaux indépendants et concomitants sur le projet CertiKOS ont montré une propriété similaire sur un ordonnanceur. Cependant leur ordonnanceur est limité à l'ordonnancement de \emph{jobs} provenant de tâches périodiques.

	\section{Description structurelle}

		Cette section décrit la structure générale de l'ordonnanceur. Elle commencera par sa partie phare, la fonction d'élection. Cette section en donnera une description fonctionnelle, ainsi que son prototype. Cette section décrira ensuite la place de l'ordonnancement dans Pip. Elle discutera du choix de placer l'ordonnanceur dans une partition, et des différences principales avec un système d'exploitation classique tel que Linux. Enfin, cette section détaillera les composants de l'ordonnanceur, leur fonction ainsi que leurs interactions.

		\subsection{Définition prototype et oracle de la fonction d'élection}

		La fonction d'élection est le morceau de logiciel que l'ordonnanceur doit appeler à chaque préemption, afin d'élire le prochain flôt d'exécution du système. La fonction d'élection fait ce choix en accord avec une politique d'ordonnancement qui lui permet de discriminer les flôts d'exécution selon des critères spécifiques qui sont propres à chaque politique. En particulier, la fonction d'élection de notre contribution suit la politique d'ordonnancement \emph{Earliest Deadline First}, qui est une politique temps réel dont la priorité est d'exécuter les \emph{jobs} dont l'échéance est la plus proche.

		La fonction d'élection de notre ordonnanceur agit comme un oracle, ne prennant aucun argument et retournant un type composite. Ce type composite contient un booléen indiquant à l'ordonnanceur qu'il doit attendre la prochaine préemption car il n'y a aucun \emph{job} à exécuter. Ce type contient l'identifiant du \emph{job} à exécuter dans le cas contraire, ainsi qu'un autre booléen indiquant si le \emph{job} a dépassé son échéance. Ce dernier booléen sert à informer l'ordonnanceur que l'ensemble des \emph{jobs} n'est pas ordonnançable. 

		\begin{listing}[!ht]
			\coqcode{code/electionfunction.v}
			\caption{Prototype de la fonction d'élection et définition de son type de retour }
		\end{listing}

			\subsubsection{Exemple d'appel à la fonction d'élection}

			\textcolor{red}{Exemple de résultats produits par l'ordonnanceur sur un ensemble de deux jobs comme dans la présentation à RTAS2022}

		\subsection{Place de l'ordonnancement dans Pip}

		Cet ordonnanceur ne s'exécute pas en espace privilégié, comme c'est le cas dans les systèmes d'exploitation traditionnels tels que Linux ou même dans des systèmes d'exploitation de niche tels que seL4. 

		La première raison en faveur d'une implémentation de l'ordonnanceur dans une partition de Pip concerne la méthode de conception des logiciels autour de Pip. En effet, placer l'ordonnanceur en espace utilisateur lui fait implicitement profiter des propriétés d'isolation des partitions de Pip. Ce choix est en adéquation avec la vision de Pip du système, conçu comme une tour de virtualisation. Dans le modèle de Pip, les différents logiciels se construisent les uns au dessus des autres, profitant des propriétés prouvées sur le logiciel sous-jacent.

		La seconde raison est une conséquence directe de ce choix, relatif à l'effort de preuve. Si l'ordonnanceur avait été implémenté dans Pip, alors il aurait fallu montrer que l'ordonnanceur respecte les propriétés d'isolation de Pip. \textcolor{red}{Inclure les métriques pour argumenter que cet effort serait non négligeable}. De plus, l'ordonnanceur développé dans cet contribution a été conçu autour de la politique d'ordonnancement EDF. Ce choix est arbitraire, et il serait tout à fait pertinent d'utiliser une autre politique d'ordonnancement pour Pip. Ainsi, il faudrait prouver les propriétés d'isolation de Pip pour chaque variante de l'ordonnanceur engendrée par chaque politique souhaitée.

		\subsection{Décomposition des éléments de l'ordonnanceur}
			\subsubsection{Vue générale}
			\begin{figure}[!ht]
			    \centering
			    \input{figures/scheduler_overview.tex}
			    \caption{Overview of the scheduler components and their interactions}
			    \label{fig:project_overview}
			\end{figure}


			La figure \ref{fig:project_overview} donne une vue générale des composants de l'ordonnanceur et de leurs interactions. Le \emph{back-end} est le point d'entrée de l'ordonnanceur. Il est appelé par le noyau lorsqu'une interruption survient, appelle la fonction d'élection puis exécute le \emph{job} choisi par la fonction d'élection. Le \emph{back-end} doit aussi mettre à jour une partie de l'état sur laquelle repose la fonction d'élection, que nous appelons l'environnement. L'environnement est la partie de l'état disponible en lecture seule à la fonction d'élection, que la fonction d'élection peut interroger au travers des \emph{oracles}. La seconde partie est la partie mutable de l'état, que la fonction d'élection ne peut manipuler qu'au travers de l'\emph{interface}, principalement composée de types de données et de fonction pour les manipuler.

		\subsubsection{État interne de l'ordonnanceur}

			L'état interne de l'ordonnanceur est chargé de stocker les informations nécessaires à la fonction d'élection pour calculer le prochain \emph{job} à élire. Il existe deux représentations de cet état : une implémentation exécutable, et un modèle utilisé pour la preuve.

			L'état est -- de sucroit -- divisé en deux parties, qui se distinguent par leur fonction par rapport à la fonction d'élection. La première partie de l'état est maintenue par la fonction d'élection, qui peut y lire et y écrire des données à sa guise en utilisant l'interface de l'état prévue à cet effet. Cette partie de l'état est appelée l'état mutable. La seconde partie est la partie de l'état que la fonction d'élection ne peut qu'observer, qui est appelé l'environnement. L'environnement contient les informations relatives aux évènements extérieurs essentiels au bon fonctionnement de l'ordonnanceur, tels que l'arrivée de nouveaux \emph{jobs} à ordonnancer, ou la complétion d'un \emph{job} précédemment exécuté. Cette partie de l'état est donc accessible en lecture seule à la fonction d'élection. La fonction d'élection peut consulter l'environnement aux travers d'oracles, qui servent d'interface avec l'environnement.

		\subsubsection{Interface avec l'état (types abstraits et oracles)}
			
			Comme indiqué dans la sous-section précédente, la fonction d'élection effectue des modifications sur l'état ou observe l'environnement grâce à l'interface et aux oracles. Cette interface est \emph{nécessaire} car elle permet de définir les opérations qui doivent être supportées par l'état, et donc par ses deux représentations (le code exécutable et le modèle). Sans cette interface, certaines opérations pourraient être possible dans une des deux représentations sans qu'elle soit possible dans l'autre.
			L'interface ainsi que les oracles sont composés de types opaques, implémentés de manière indépendante dans les modèles ou dans le code exécutable. Ces types sont munis de fonctions elles aussi pourvues d'une implémentation exécutable ainsi que d'un modèle.

			Les oracles sont une partie de l'interface spécifique. Les oracles sont la partie de l'interface qui permet à la fonction d'élection d'oberserver les phénomènes extérieurs à l'algorithme de la fonction d'élection. Bien qu'ils disposent aussi de deux représentations, leur modèle ne décrit pas réellement les résultats que l'oracle doit produire, mais plutôt des contraintes sur les résultats produits. Le modèle va se contenter de décrire l'ensemble des résultats possibles, plutôt que d'en désigner un en particulier.

		\subsubsection{Back-ends}
		\label{sec:back-ends}

		Nous avons vu que l'état est composé en partie d'une partie non mutable, appelée l'environnement. Les informations contenues dans l'environnement sont mises à jour par le \emph{back-end}. Le \emph{back-end} est aussi chargé d'appeler la fonction d'élection et d'exécuter le \emph{job} qui aura été élu.

		Cette contribution est munie de deux \emph{back-ends}.
		\begin{itemize}
			\item Le premier back-end est conçu comme une simulation permettant d'exécuter la fonction d'élection dans un simple processus Linux, afin de fournir des informations sur l'état interne de l'ordonnanceur. Ce back-end appelle la fonction d'élection, affiche le \emph{job} choisi pour exécution et autres informations d'intérêt sur l'état interne de la fonction d'élection tels que la liste des \emph{jobs} en attente, etc ;

			\item Le second back-end fourni est l'implémentation d'un ordonnanceur Earliest Dealine First dans une partition de Pip. Cette implémentation exécute la fonction d'élection et transfère le flôt d'exécution vers le \emph{job} élu par la fonction d'élection. Chaque job se trouve dans sa propre partition, avec un espace d'adressage qui lui est propre. Le flôt d'exécution revient au back-end soit lorsqu'une interruption d'horloge survient, interrompant le \emph{job} élu, soit lorsque le \emph{job} lui signale sa terminaison. Le back-end attend alors la prochaine interruption pour réélire un nouveau \emph{job}.
		\end{itemize}

		Les back-ends ne font pas partie du modèle mathématique de l'ordonnanceur, si ce n'est au travers des \emph{oracles}.

		\subsubsection{Fonction d'élection}

		La fonction d'élection est divisée en deux parties principales. La première partie maintient la liste des \emph{jobs} en attente et sélection le prochain \emph{job} à exécuter, la seconde maintient la cohérence de son état interne.

		Dans la première partie, la fonction d'élection invoque un oracle, qui lui retourne la liste des nouveaux \emph{jobs} à ordonnancer. Ces jobs sont ajoutés à la liste des jobs à ordonnancer. Ensuite, elle invoque un autre oracle qui lui renvoie l'état du dernier job exécuté, afin de vérifier s'il a complété son exécution ou s'il a dépassé son échéance. S'il remplit l'une de ces deux conditions, il est enlevé de la liste des jobs à ordonnancer. Si il a excédé son échéance, l'erreur sera remontée lors du retour de la fonction. Enfin, la fonction récupère l'identifiant du premier \emph{job} de la liste (si la liste n'est pas vide) et le retourne avec le drapeau indiquant si le dernier \emph{job} exécuté a dépassé son échéance. Une valeur par défaut est retournée si aucun \emph{job} n'est disponible.

		La seconde partie de la fonction d'élection maintient la cohérence de l'état interne de la fonction d'élection pour les futurs appels. Elle commence par décrémenter le budget d'exécution du \emph{job} élu. Elle décrémente ensuite l'échéance relative des \emph{jobs} en attente, pour tenir compte du temps qui sera passé à exécuter le \emph{job} élu. Finalement, la fonction d'élection incrémente le compteur de temps, qui garde le compte de périodes de temps s'étant écoulées depuis le premier appel à la fonction d'élection.

	\section{Conduite de la preuve}

	\label{sec:proof}
	In this section we outline the proof of correctness of the monadic Gallina program for the EDF scheduler.
	We first describe our methodology, which is a top-down refinement approach between three abstraction levels. Then we show the abstraction levels and the refinements between them, focusing on why the refinement steps preserve the correctness properties proved at higher levels. Finally we give some details about the Coq implementation of the approach.


	\subsection{Methodology}

	We use refinement %\cite{wirth1971program, morris1987theoretical} 
	as a divide-and-conquer strategy to manage the complexity of our formal proof.
	We first define the EDF scheduling policy at an abstract level and show that,
	under appropriate assumptions, formalized below, the policy is \emph{correct},
	in the sense that any set of schedulable jobs is scheduled so all jobs complete
	their execution within their deadline. Then we write a functional algorithm and
	show that it implements the abstract scheduling policy. It follows that the functional
	algorithm is also correct. The final step is to write a monadic scheduler,
	detailed enough to be automatically translatable to C, and to show that
	the monadic scheduler refines the functional one; as a result, the monadic scheduler is correct as well.
	%The properties proved in our work act as layered invariants that extend from the EDF policy model to the monadic code. To prove a new refinement layer, we start from the invariant of the previous (more abstract) layer and show that the new invariant \emph{refines} the previous one, i.e., the new invariant has a more detailed specification that remains compatible with its more abstract version.
	%All the proofs that we performed rely on the following assumptions.

	\subsubsection{Job model}
	\label{sec:jobmodel}
	Jobs are modelled as tuples $j = (i_j, r_j,d_j,c_j, \delta_j)$  of natural numbers, where $i_j$ is the job's identifier, $r_j$ is its release date (i.e., the date at which it becomes available for scheduling), $d_j$ is the job's deadline, and $c_j$ is the job's budget a.k.a. WCET, which is an over-approximation of the job's actual duration $\delta_j$. The jobs satisfy the following well-formedness constraints:
	$r_i + c_i \leq d_i$, i.e., the deadline is large enough for the job to complete when executed alone on the processor; and $0 < \delta_j \leq c_j$, i.e., the WCET is indeed an over-approximation of the actual running time, which is itself strictly greater than zero. Moreover, it is assumed that identifiers uniquely determine jobs and that every job is released exactly once.


	\subsubsection{Schedulability assumption}

	Given any two moments $t$ and $t'$ such that $t < t'$,
	let $\Gamma_{t, t'}$ be the set of jobs to schedule in the interval $[t, t']$
	(i.e. jobs $j$ for which their release time $r_j$ is at least $t$ and their deadline $d_j$ is at most $t'$).
	The schedulability condition requires that the sum of durations $\delta_j$ of the jobs to schedule in the interval $[t, t']$ is at most the length $t'-t$ of the interval.

	\begin{gather} \label{eq:schedulability}
    		\forall t, t'. ~t < t' \implies
    		\sum_{j \in \Gamma_{t, t'}}\delta_j \leq t' - t
	\end{gather}
%% \text{with:}
%% \begin{align*}
%%               \rho, \delta&\text{, arbitrary time instants},\\
%%               \Gamma_{\rho, \delta}&\text{, the set of jobs to schedule in the interval $[\rho, \delta]$},\\
%%               J_i&\text{, a job from }\Gamma_{\rho, \delta},\\
%%               r_i,~d_i,~C_i &\text{, respectively the release time, the deadline,}\\&\text{~~and the WCET of }J_i
%% \end{align*}
	The fact that the schedulability of a given set of jobs implies that the set of jobs is schedulable by EDF on a single processor
	is a textbook result in schedulability theory (\cite{stankovic2012deadline}, pp. 33-34). It is also known that the schedulability condition has simpler forms in particular cases, e.g.,  for jobs that are instances of periodic tasks~\cite{stankovic2012deadline}; but in this paper we are concerned with an  EDF scheduler  applicable to a general set of jobs, so we shall not consider particular cases of the schedulability condition.

	The study of job schedulability is a separate area of research.
	In this work we merely use some results from schedulability theory and prove them formally in Coq.
	Our proof-of-concept scheduler is bundled with a simple schedulable job set for demonstration and reproducibility purposes.


	\subsection{Abstraction levels and refinement steps}

	\subsubsection{EDF scheduling policy}
	\label{sec:policy}
	The first and most abstract level for proofs is that of the EDF
	scheduling policy, which can be defined as follows: for any job $j$ and any time instant $t$, if the job $j$ is running at instant $t$,
	then for any other job $j'$ that is ready to run at the same instant, it holds that $d_j \leq d_{j'}$.

%Formally,
%% \begin{equation*}
%%      \forall i, \forall t, [...]~\text{run}~i~t = true \implies
%%      \forall x,~\text{waiting}~x~t \implies d_i \leq d_x.
%% \end{equation*}
%% \text{with:}
%% \begin{align*}
%%               i, x&\text{, job identifiers},\\
%%               t&\text{, an arbitrary time instant},\\
%%               \text{run}~i~t&\text{, \emph{true} iff $J_i$ is running at instant $t$},\\ 
%%               \text{waiting}~x~t&\text{, \emph{true} iff $J_x$ is waiting to run at instant $t$}
%% \end{align*}
	The \emph{correctness property} for the EDF scheduling policy is stated as follows.
	Given a set of schedulable jobs, i.e., jobs satisfying the schedulability assumption~(\ref{eq:schedulability}), when the EDF scheduling policy is applied,
	no job in the set ever exceeds its deadline.
	
	\begin{gather*}
  		\text{schedulable} \implies\\
  		\forall j, \forall t. ~\text{EdfPolicyUpTo}~t \implies \neg \text{overdue}~j~t.
	\end{gather*}
	where {EdfPolicyUpTo}~$t$ means that the EDF policy was  applied up to the instant $t$, and
	{overdue}~$j$~$t$ = \emph{true} iff the job $j$ missed its deadline at instant $t$.

	\subsubsection{Functional EDF implements EDF policy}
	\label{sec:functional}
	The first refinement step is to prove that our functional EDF election function \texttt{functional\_scheduler\_star} implements the EDF policy. The following property states that if the functional election function has been executed up to a certain time instant $t$, then the EDF policy has been applied up to that instant.
	\begin{gather*}
		\forall t, \forall o, \forall s.\\ 
		~\texttt{functional\_scheduler\_star}~(t) = (o,s) \implies\\
		\text{EdfPolicyUpTo}~(\text{now}~s).
	\end{gather*}
	\text{with:}
	\begin{align*}
              s&\text{, the state of the program after executing the}\\
	       &\text{~~functional election function for $t$ time units},\\
	      %\texttt{functional\_scheduler\_star}~(t)&\text{an execution of the functional election function up to the instant $t$}
              %\text{EdfPolicyUpTo}~t&\text{, the policy applied up to a given instant $t$},\\ 
              \text{now}~s&\text{, extracts the current time from the state $s$.}\\
	      o~&\text{, the id of the chosen job at instant $t$}
	\end{align*}

From this property one can derive the property expressing the correctness of the functional EDF program:
given a schedulable job set and any job $j$ from this set, that job will not exceed its deadline at the instant $t$ if the functional EDF algorithm has been applied up to the instant $t$.

	\begin{gather*}
		\text{schedulable} \implies\\
		\forall t, \forall o, \forall s.\\
		\texttt{functional\_scheduler\_star}~(t) = (o,s) \implies\\
		\forall i.~\neg \text{overdue}~i~(\text{now}~s).
	\end{gather*}

	\subsubsection{Monadic EDF refines functional EDF}
	\label{sec:monadic}
	The next step consists in proving that the monadic scheduler is a refinement of the functional one. We  use Hoare triples \cite{hoare1969axiomatic} for writing this property in a formal manner.
	A Hoare triple has the following form: $\{ P \}~c~\{ Q \}$. $\{ P \}$ stands for the \emph{preconditions}, the properties of the program state that hold before the program is executed. $c$ represents the program, the sequence of instructions to be executed. $\{Q \}$ stands for the \emph{postconditions}, the properties that hold after the program is executed.

	The preconditions are parameterized by an observable environment \emph{env} and by a mutable state $s$. The postconditions are parameterized by the return value $o$ of the program $c$, and a state $s'$, the result of executing the program $c$ on $s$.

	The refinement step is informally described as follows: for any given moment $t$, if $(o, s')$ is the result of the execution of the monadic EDF election function \texttt{scheduler\_star} on the environment $E$ and the initial state $init$, then $(o, s')$ is also the result of the functional EDF election function \texttt{functional\_scheduler\_star} at the instant $t$. The corresponding Hoare triple is :

	\begin{gather*}
		\forall t.\\
		\{
		~\lambda~\textit{env}~s. ~\textit{env} = E \land s = \textit{init}~
		\}\\
		\texttt{scheduler\_star}~(t)\\
		\{
		~\lambda~o~s'. ~\texttt{functional\_scheduler\_star}~(t) = (o,s')~
		\}
	\end{gather*}

	From this triple, one gets a Hoare triple expressing the monadic program's correctness property.

	\begin{gather*}
		\textit{schedulable} \implies\\
		\forall t.\\
		\{
		~\lambda~\textit{env}~s. ~\textit{env} = E \land s = \textit{init}~
		\}\\
		\texttt{scheduler\_star}~(t)\\
		\{
		~\lambda~o~s'. ~\forall i,~\neg \textit{overdue}~i~(\textit{now}~s') ~
		\}
	\end{gather*}


	\subsection{The proofs in Coq}
	Our Coq proofs closely follow the top-down refinement approach outlined above. First, the job model, mathematically described in Section~\ref{sec:jobmodel}, is encoded in Coq. The assumptions listed in~\ref{sec:jobmodel} (specifically: each deadline is large enough for a job to complete its execution when running alone on the processor; job durations are greater than zero and are over-approximated by the respective budgets; identifiers uniquely determine jobs; and every job is released exactly once) are global assumptions of the proof. Arguably, the global assumptions are just reasonable well-formedness constraints.



	At the highest abstraction level (EDF policy) there are additional \emph{local} assumptions.
	The local assumptions are only used in the proof of correctness of the EDF scheduling policy. When the policy is subsequently
	refined into an algorithm the local assumptions disappear - they become Coq definitions and lemmas.
	Two abstract functions are locally assumed: \texttt{run}, which determines which job (if any) is  running at a given moment, and \texttt{rem}, that keeps track of the remaining execution time for any given job and at any given moment.
	The following facts are also locally assumed about these functions, which model general facts about monoprocessor scheduling:
	
	\begin{itemize}
		\item at any moment in time, at most one job is running;
		\item up to and including its release time, the remaining execution time of a job equals its duration;
		\item the remaining execution time of a job decreases when the job is running, and stays constant otherwise;
		\item whenever there is at least a released job with non-zero remaining execution time, there is one job that is running.
	\end{itemize}

	Under the said local assumptions the correctness proof of the EDF policy is mostly a matter of algebraic calculations. It is relatively short: $\sim$1000 lines, mostly due to the fact that at this abstraction level one can focus on the essentials, without having to deal with implementation details.

	The first refinement step, from EDF policy to EDF functional scheduler, amounts for the largest part of the proof effort. Essentially, this is because there is a substantial abstraction gap between the EDF policy level, which is written in relatively simple algebraic terms, and the functional-scheduler level, which encodes the policy in terms of a rather detailed list data structure. The refinement consisted in defining concrete versions of the abstract functions locally assumed at the EDF policy level - \emph{run} and \emph{rem} - in terms of the said list structure, and in proving the properties relating these functions, which at the EDF policy level were locally assumed. Once this is done, the correctness of the EDF functional algorithm is a simple conjunction between the correctness of the EDF policy and the fact that the function scheduler implements the policy. Proving an implementation relation instead of the global correctness property on the functional scheduler is easier, since the proof obligations for the implementation relation are more detailed than the global correctness property: there are fewer details that need to be "filled in" by additional proofs.

	All the properties to be proved are invariants - predicates that hold at all states reachable from an initial state, obtained by executing the functional scheduler any finite number of times. The proof required us to discover additional \emph{inductive} invariants, which hold initially and whose truth is preserved by each execution of the scheduler. Such invariants have to be chosen so that together they imply the original invariant. This is where creativity is required from the user. Together with the functional scheduler this step amount to $\sim$1600 lines of code.

	By comparison, the second (and last) refinement step is short ($\sim$500 lines). It amounts to proving that, starting from a given initial state, the reachable states generated by running the monadic EDF scheduler are included in the states generated by running the functional EDF scheduler. This was relatively easy (especially compared to the first refinement step) because the functional and monadic schedulers are relatively close in terms of abstraction level; e.g., they work with the same data structures. The difference lies in the fact that the functional scheduler computes in one large step what the monadic one computes in a sequence of many small steps.  The functional algorithm is not subject to such requirements, thus, it is free to "compact" a long sequence of small steps into a large single step. By doing so the functional scheduler also saves us from the effort of proving even more additional invariants, about intermediary states that the monadic scheduler generates.  
\indent The global conclusion that the monadic EDF scheduler is correct follows from the correctness of the abstract EDF policy and the correctness of the two successive refinements.

	\section{Mise en oeuvre / Implémentation}
		\subsection{Dualité implémentation/modélisation}
			% Méthode générale
		
		\subsection{Implémentation vue comme un cas particulier de l'interface abstraite}
	\label{sec:monad}

	In this section we detail how the interface of the verified code - the monad - is designed. The monad is simply a specification of how the interface should behave. We also explain the differences between the monad's model and its actual implementation.
	The various parts are represented in Figure \ref{fig:project_overview}.

	We start by detailing the verified code's internal state, which is composed of two parts: a read-only part that we call the environment, and a mutable part. Then, we introduce a model-blind software that computes the information held in the environment, that we call the back-end. Next, we  explain how the verified code can retrieve the information from the environment. Finally, we give details about the interface that allows the verified code to interact with the mutable part of the state.

	\subsection{Program state}

	The state model is divided into two parts: a part containing the values over which the algorithm has no control, its \emph{environment}, which is immutable. These values are provided by the back-end. The second part of the model contains the values over which the algorithm has control and which are therefore mutable.

	The environment is defined as a function that, given a certain timestamp, returns a list of jobs to add to the pending jobs list.
	%\begin{verbatim}
	\begin{minted}{coq}
Definition Env : Type := CNat -> list Job.
	\end{minted}
	%\end{verbatim}

	The mutable state model consists of structure with two fields. The first is simply a time counter and the other is a list of \emph{entries}. Entries are structures that associate jobs with their remaining time budget and relative deadline. The state is therefore defined as follows:
	%\begin{verbatim}
	\begin{minted}{coq}
Record State := 
mk_State {
    now : CNat ;
    active : list Entry ;
}.
	\end{minted}
	%\end{verbatim}

	The resulting state model, composed of both mutable and immutable parts, has the following type:
	%\begin{verbatim}
	\begin{minted}{coq}
Definition RT (A : Type) : Type :=
    Env -> State -> A * State.
	\end{minted}
	%\end{verbatim}

	We now describe how the state is implemented.
	The implementation takes advantage of the fact that the election function creates a single structure for each job. Essentially, the implementation reserves additional memory space for each job to be scheduled, which the algorithm uses to store the related Entry structure.

	Thus, there is an array of \texttt{coq\_N} elements (where \texttt{coq\_N} is the static upper bound on the number of jobs to be scheduled) that contains the initial immutable information about the pending jobs, as well as the additional mutable memory that the algorithm needs. The jobs are identified by their own index in this array. Each element of this array also contains two additional memory words. These memory bits are used to maintain the various lists required by the algorithm: the list of newly available jobs to be scheduled from the environment and maintained by the back-end, and the list of jobs pending execution from the internal state of the program, maintained by the algorithm).

	So this large array has elements of type:
	%\begin{verbatim}
	\begin{minted}{c}
typedef struct __internal_s__ {
    struct __internal_job__   job;
    struct __internal_entry__ entry;
    int jobset_next_job_index;
    int active_next_entry_index;
} internal_t;
	\end{minted}
	%\end{verbatim}

	The overall state of the program consists of this big array, the heads for the two different lists, the clock counter variable from the mutable state, and a variable that indicates whether the last job completed its execution (which is manipulated by the back-end):

	%\begin{verbatim}
	\begin{minted}{c}
internal_t INTERNAL_ARRAY[coq_N] = EXAMPLE_JOB_SET;

int JOBS_ARRIVING_HEAD_INDEX = -1;
int ACTIVE_ENTRIES_HEAD_INDEX = -1;

unsigned int CLOCK = 0;
coq_CBool  JOB_DONE = false;
	\end{minted}
	%\end{verbatim}

	\subsection{Oracles}

	There are two oracle primitives that return values managed by the back-end code and abstract to the model. The first, \texttt{jobs\_arriving}, retrieves the new jobs that need to be added to the pending job list; the other, \texttt{job\_terminating}, returns whether the last executed job completed its execution (if such a job exists). \footnote{Their model is available in \texttt{src/coq/model/Interface/Oracles.v}, while their C interface implementation can be found in \texttt{src/interface\_implementation/include/Primitives.h}.}

	The monadic code can retrieve the identifiers of incoming jobs via an oracle that reads the environment. The model imposes a single constraint on the implementation: in the list of job identifiers returned by the oracle, no identifier may be greater than $N$, where $N$ is a predefined static upper bound. 

	%\begin{verbatim}
	\begin{minted}{coq}
Definition jobs_arriving (N : nat) : RT JobSet :=
  fun env s =>
    let f :=  List.filter
      (fun j =>  Nat.ltb j N)
      (map jobid (env s.(now))) 
  in (f, s).
	\end{minted}
	%\end{verbatim}

	We would like to draw the reader's attention to the fact that the model is \textbf{purely abstract}; it does not indicate which jobs are ready for execution, since the scheduling algorithm does not rely on this information. Also note that the list of identifiers is hidden behind the abstract type \texttt{JobSet}.

	In contrast, the implementation of the function that returns the oracle's prediction is quite simple:

	%\begin{verbatim}
	\begin{minted}{c}
static inline coq_JobSet
Primitives_jobs_arriving(coq_CNat n) {
     return JOBS_ARRIVING_HEAD_INDEX;
}
	\end{minted}
	%\end{verbatim}

	The implementation simply reads the index of the first arriving job from the environment. The list of incoming jobs is previously created by the back-end, so the actual list creation process depends on the back-end.

	The other oracle is a function that returns whether the job with the most critical deadline (at the head of the list maintained by our scheduler) has completed its execution. The model is stricter with this oracle. It forces the implementation to return \texttt{True} if time spent executing the job is greater than its theoretical WCET.

	\vspace{1cm}

	Here is the (nested) model definition:

	%\begin{verbatim}
	\begin{minted}{coq}
Definition job_terminating : RT CBool :=
fun _ s => ((
    match head s.(active) with
    | None => false
    | Some e =>
        let j := Jobs (e.(id)) in
        Nat.leb e.(cnt) (j.(budget) - j.(duration))
    end
), s).
	\end{minted}
	%\end{verbatim}

	Note that the counter \texttt{e.(cnt)} is decremented from an initial value of \texttt{j.(budget)} each time the job is scheduled for execution. 

	Like the previous oracle, the implementation that returns the result of the oracle is very simple:

	%\begin{verbatim}
	\begin{minted}{c}
static inline coq_CBool Primitives_job_terminating(void) {
    return JOB_DONE;
}
	\end{minted}
	%\end{verbatim}

	The implementation only returns the variable \texttt{ JOB\_DONE} from the internal state. This variable is updated by the back-end when needed.

	We now review the software that allows the verified code to interact with the mutable state.

	\subsection{Abstract Types}

	All types used by the verified code are abstract types (black box types). These types have their own interface. 

	There are abstract types for Boolean values, integers, read-only job structures, and read-write job structures. Most of the primitives are simple and straightforward functions for specific data types. For example, there are 3 primitives for the boolean type \texttt{CBool} : \texttt{not}, \texttt{and}, and \texttt{or}.
	Here one can see the model of type CBool together with the boolean primitive \texttt{or}:

	%\begin{verbatim}
	\begin{minted}{coq}
Definition CBool := bool.

Definition or (b1 b2 : CBool) : RT CBool :=
  ret (orb b1 b2).
	\end{minted}
	%\end{verbatim}

	The actual implementation is defined as follows:

	%\begin{verbatim}
	\begin{minted}{c}
typedef int coq_CBool;

static inline coq_CBool CBool_or(coq_CBool b1, coq_CBool b2) {
    return b1 || b2;
};
	\end{minted}
	%\end{verbatim}

	Mutable structures such as type \texttt{Entry} are given primitives for creating the structure and for accessing and modifying their fields. In the same fashion, read-only data structures are only given access primitives. For example, the type \texttt{JobSet} returned by the oracle \texttt{jobs\_arriving} has only three primitives : one to check for emptiness of the set, another to get the first \texttt{Job}, and a final one to get the remaining \texttt{Jobs}. The \texttt{Job} type only has primitives that return the fields of the structure. \footnote{All model definitions for these types are available in the \texttt{src/coq/model/Interface/Types} directory.}


	Finally, there is another set of eight primitives that interact directly with the internal state of our program. The program needs to manage a counter to keep track of time. For this, we have two primitives, a getter and a setter for the counter.

	These functions are trivially modeled and implemented:

	%\begin{verbatim}
	\begin{minted}{coq}
Definition get_time_counter
: RT CNat :=
  fun _ s => ((now s), s).

Definition set_time_counter
(counter : nat) : RT unit :=
  fun _ s => (tt,
    {|
      now    := counter ;
      active := (active s) ;
    |}
  ).
	\end{minted}
	%\end{verbatim}

	%\begin{verbatim}
	\begin{minted}{c}
static inline coq_CNat
State_get_time_counter(){
    return CLOCK;
};

static inline void
State_set_time_counter(coq_CNat counter){
    CLOCK = counter;
};
	\end{minted}
	%\end{verbatim}
	The scheduler also needs to maintain a list of pending jobs. It consists of six primitives, including one primitive that determines whether jobs are present in the list, and another that returns the ID of the job located at the head of the list (if any). Two other primitives respectively add a new job to the list (in sorted form) and remove the first job from the list. The last two primitives are meant to update job structures: either just the first job or the entire list. \footnote{Their model are in the \texttt{src/coq/model/Interface/Types/State.v} file, while their implementation are in the \texttt{src/interface\_implementation/State.c} file. (The simplest ones are inline functions located in the corresponding header).}

	\begin{figure*}[!ht]
	    \centering
	%    \begin{verbatim}
	    \begin{minted}{coq}
Definition insert_new_active_entry (entry : Entry)
           (comp_func : Entry -> Entry -> CBool) : RT unit :=
  fun _ s => (tt, {|
    now := now s ;
    active := (insert_Entry_aux entry (active s) comp_func);
  |}
).

Fixpoint insert_Entry_aux (entry : Entry) (entry_list : list Entry)
         (comp_func : Entry -> Entry -> CBool) : list Entry :=
  match entry_list with
  | nil => cons entry nil
  | cons head tail =>
      match comp_func entry head with
      | true => cons entry (cons head tail)
      | false => cons head (insert_Entry_aux entry tail comp_func)
      end
  end.
	    \end{minted}
	%    \end{verbatim}
	    \vspace{0.2cm}
	    \hrule
	    \vspace{0.2cm}
	%    \begin{verbatim}
	    \begin{minted}{c}
void State_insert_new_active_entry
     (coq_Entry entry, entry_cmp_func_type entry_comp_func) {
  int *entry_index_ptr = &(ACTIVE_ENTRIES_HEAD_INDEX);
  int next_index = -1;
  while (*entry_index_ptr != -1) {
    if (entry_comp_func(entry, &(INTERNAL_ARRAY[*entry_index_ptr].entry))) {
      next_index = *entry_index_ptr;
      break;
    }
    entry_index_ptr = &(INTERNAL_ARRAY[*entry_index_ptr].active_next_entry_index);
  }
  *entry_index_ptr = entry->id;
  INTERNAL_ARRAY[entry->id].active_next_entry_index = next_index;
}
	    \end{minted}
	%    \end{verbatim}
	    \caption{Side by side comparison between the model of a sorted list insertion primitive and its actual implementation}
	    \label{fig:model_impl_cmp}
	\end{figure*}

	Most of these primitives are both simple to model and implement, but two of them are not so easy to implement. The first one is \texttt{insert\_new\_active\_entry}, which inserts an entry (an internal representation of a job to execute) sorted by an arbitrary comparison function. Its model is given in the first half of Figure \ref{fig:model_impl_cmp}.

	Given an entry and a comparison function, this model extracts the list from the current state of the program. It passes it to a (non-monadic) auxiliary recursive function that returns the list with the newly inserted entry.

	This helper function then constructs a completely new list by comparing each entry from the list with the new list, using the comparison function from the parameters. 

	Of course, one can not afford to copy the list every time an item is inserted. The implementation uses in-place insertion in the list. The interface chosen to interact with the state prevents a mismatch between the model and reality, where one creates new lists while the other modifies the list in-place.

	This code is conceptually the same as the recursive functional version, but uses loops and updates the required links between elements when a new element is inserted, rather than creating new elements and cleverly rearranging them.

	The same technique was used to model and implement the function \texttt{update\_active\_entries}, which applies an arbitrary modification to each entry in the list. The implementation modifies the elements of the list in-place rather than creating a new list with modified copies of entries.

	\label{sec:implementation}

	We argue that all the primitives described in this section are simple enough to trust that the implementation actually conforms to the model. Nevertheless, the last two primitives are arguably complex enough to shake this confidence. We discuss this point further in Section \ref{sec:discussion}.

	\section{Discussion sur la méthodologie suivie}
		\subsection{Métriques}
		\subsection{Choix des primitives}
