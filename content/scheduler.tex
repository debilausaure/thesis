\chapter{Politique d'ordonnancement prouvée}

	Le chapitre précédent a porté sur un service de transfert de flôt d'exécution au sein de Pip. Ce service permet de gérer les transferts explicites de flôt d'exécution, ainsi que les interruptions. De cette manière, Pip fournit les outils nécessaires à la préemption de flôts d'exécution. La préemption est nécessaire à la mise en place d'ordonnancement au sein d'un système ; elle n'est cependant pas suffisante pour implémenter un ordonnanceur. Celui-ci doit être muni d'une politique d'ordonnancement, lui permettant de choisir le prochain flôt d'exécution.

	Ce chapitre porte sur l'implémentation d'un ordonnanceur Earliest Deadline First (abrégé EDF) s'exécutant en espace utilisateur. L'ordonnanceur est conçu pour fonctionner dans une partition de Pip, et est muni d'une preuve formelle que sa fonction d'élection respecte la politique d'ordonnancement EDF. Ces travaux ont été menés conjointement avec Vlad Rusu, avec qui j'ai conçu les modèles sur lesquels reposent la preuve et qui a établit les preuves formelles sur cet ordonnanceur. Dans ce travail commun, ma contribution a été de concevoir les composants de l'ordonnanceur, leur interface ainsi qu'une partie de leur modèle, ainsi que d'écrire l'implémentation pour que cet ordonnanceur puisse être compilé et s'exécuter dans une partition de Pip.
	\footnote{David Nowak, Gilles Grimaud mais aussi Samuel Hym ont aussi contribué à ce projet de manière plus modeste. David a participé à l'élaboration des modèles, Gilles a participé à l'établissement des interfaces, et Samuel a participé à l'écriture de l'implémentation}.
	
	Ces travaux ont fait l'objet d'une publication et d'une présentation à RTAS2022, dont ce chapitre s'inspire fortement. Le papier est disponible à l'adresse suivante : \url{https://hal.archives-ouvertes.fr/hal-03671598}. La vidéo de la présentation est disponible à l'adresse suivante : \url{https://pip.univ-lille.fr/recordings/RTAS.mp4}. Le dépot contenant le code ainsi que les instructions pour exécuter l'ordonnanceur est hébergé sur Github : \url{https://github.com/2xs/pip_edf_scheduler}.

	\section{Motivations}
	
	% Autre type de preuve : garantir le respect des échéances / pourquoi est ce vraiment critique ?
	La motivation première de cette contribution est de proposer des garanties supplémentaires aux garanties d'isolation classiques de Pip. Cette motivation nous a mené à nous intéresser aux problématiques des systèmes temps réel, et notamment sur le respect des échéances, car nous pensons que la vision de Pip peut être pertinente. La preuve formelle du respect de la politique d'ordonnancement est un premier pas vers des garanties temps réel dans l'écosystème de Pip.

	% Intro : ce qu'on va étudier : utliser notre méthode de dévelopement de logiciel pour prouver un algorithme de selection des cibles du transfert de flot d'exécution autres propriétés que l'isolation
	Cette contribution est aussi un moyen d'éprouver la méthode de développement des logiciels et preuves de Pip, en l'appliquant à un autre objet d'étude. On peut noter deux différences fondamentales entre Pip et cet ordonnanceur. La première est que Pip s'exécute en mode privilégié, contrairement à l'ordonnanceur qui s'exécute en espace utilisateur. Cette différence a des répercussions sur la conception des interfaces ; la dépendance à du code non prouvé est moins critique en espace utilisateur. Cette différence a aussi un impact implicite sur les preuves : la logique de Hoare n'est valable que lorsque l'état ne change pas entre deux instructions -- il faut donc s'assurer que les interruptions ne perturbent pas l'ordonnanceur. La seconde réside dans le fait que les propriétés prouvées sur l'ordonnanceur relèvent de l'ordre des propriétés fonctionnelles, c'est à dire qui décrivent le comportement de l'ordonnanceur. Les propriétés d'isolation de Pip traditionnellement prouvées au travers de cette méthode ne sont pas des propriétés fonctionnelles. Aussi, nous ne chercherons pas à établir des propriétés non-fonctionnelles sur la préemption telles que des propriétés sur le partage du temps d'exécution du processeur. Ces deux différences font de cet ordonnanceur un objet d'étude intéressant du point de vue du développement logiciel.

	De plus, cette contribution utilise tous les aspects du service de transfert de flôt d'exécution décrit dans le chapitre précédent. Cette contribution permet d'exhiber par l'expérience que l'utilisation de ce service est pertinente dans un composant commun de système d'exploitation.
	
	Enfin, cette contribution apporte une preuve inédite à la communauté des systèmes temps réels. En effet, les travaux montrant de manière formelle des propriétés sur les algorithmes d'ordonnancement sont fréquents dans la communauté. Néanmoins, peu de travaux s'intéressent à la preuve de \emph{l'implémentation} de l'algorithme, qui permettent par exemple de propager les preuves jusqu'au code compilé, et qui tiennent compte de détails supplémentaires (tels que les structures de données par exemple). Cette contribution fournit une preuve formelle que l'implémentation de la fonction d'élection respecte la politique d'ordonnancement EDF pour des \emph{jobs} arbitraires, ce qui n'avait été prouvé sur aucun autre ordonnanceur EDF auparavant. Des travaux indépendants et concomitants sur le projet CertiKOS ont montré une propriété similaire sur un ordonnanceur. Cependant leur ordonnanceur est limité à l'ordonnancement de \emph{jobs} provenant de tâches périodiques.

	\section{Description structurelle}

		Cette section décrit la structure générale de l'ordonnanceur. Elle commencera par sa partie phare, la fonction d'élection. Cette section en donnera une description fonctionnelle, ainsi que son prototype. Cette section décrira ensuite la place de l'ordonnancement dans Pip. Elle discutera du choix de placer l'ordonnanceur dans une partition, et des différences principales avec un système d'exploitation classique tel que Linux. Enfin, cette section détaillera les composants de l'ordonnanceur, leur fonction ainsi que leurs interactions.

		\subsection{Définition prototype et oracle de la fonction d'élection}

		La fonction d'élection est le morceau de logiciel que l'ordonnanceur doit appeler à chaque préemption, afin d'élire le prochain flôt d'exécution du système. La fonction d'élection fait ce choix en accord avec une politique d'ordonnancement qui lui permet de discriminer les flôts d'exécution selon des critères spécifiques qui sont propres à chaque politique. En particulier, la fonction d'élection de notre contribution suit la politique d'ordonnancement \emph{Earliest Deadline First}, qui est une politique temps réel dont la priorité est d'exécuter les \emph{jobs} dont l'échéance est la plus proche.

		La fonction d'élection de notre ordonnanceur agit comme un oracle, ne prennant aucun argument et retournant un type composite. Ce type composite contient un booléen indiquant à l'ordonnanceur qu'il doit attendre la prochaine préemption car il n'y a aucun \emph{job} à exécuter. Ce type contient l'identifiant du \emph{job} à exécuter dans le cas contraire, ainsi qu'un autre booléen indiquant si le \emph{job} a dépassé son échéance. Ce dernier booléen sert à informer l'ordonnanceur que l'ensemble des \emph{jobs} n'est pas ordonnançable. 

		\begin{listing}[!ht]
			\coqcode{code/electionfunction.v}
			\caption{Prototype de la fonction d'élection et définition de son type de retour }
		\end{listing}

			\subsubsection{Exemple d'appel à la fonction d'élection}

			\begin{figure}[!ht]
			\centering{
				\input{figures/electionfunction_example.tex}
				\caption{Exemple de jobs pour l'illustration du fonctionnement de la fonction d'élection}
				\label{fig:electionfunction_jobs}
			}
			\end{figure}

			\begin{figure}[!ht]
			\centering{
				\input{figures/electionfunction_timeline.tex}
				\caption{Illustration d'un appel à la fonction d'élection sur les \emph{jobs} $a$ et $b$}
				\label{fig:electionfunction_jobs}
			}
			\end{figure}

		\subsection{Place de l'ordonnancement dans Pip}

		Cet ordonnanceur ne s'exécute pas en espace privilégié, comme c'est le cas dans les systèmes d'exploitation traditionnels tels que Linux ou même dans des systèmes d'exploitation de niche tels que seL4. 

		La première raison en faveur d'une implémentation de l'ordonnanceur dans une partition de Pip concerne la méthode de conception des logiciels autour de Pip. En effet, placer l'ordonnanceur en espace utilisateur lui fait implicitement profiter des propriétés d'isolation des partitions de Pip. Ce choix est en adéquation avec la vision de Pip du système, conçu comme une tour de virtualisation. Une tour de virualisation dont chaque étage devient partie prenante de la base de confiance (TCB) des étages supérieurs. Dans le modèle de Pip, les différents logiciels se construisent les uns au dessus des autres, profitant des propriétés prouvées sur le logiciel sous-jacent.

		La seconde raison est une conséquence directe de ce choix, relatif à l'effort de preuve. Si l'ordonnanceur avait été implémenté dans Pip, alors il aurait fallu montrer que l'ordonnanceur respecte les propriétés d'isolation de Pip. \textcolor{red}{Inclure les métriques pour argumenter que cet effort serait non négligeable}. De plus, l'ordonnanceur développé dans cet contribution a été conçu autour de la politique d'ordonnancement EDF. Ce choix est arbitraire, et il serait tout à fait pertinent d'utiliser une autre politique d'ordonnancement pour Pip. Ainsi, il faudrait prouver les propriétés d'isolation de Pip pour chaque variante de l'ordonnanceur engendrée par chaque politique souhaitée.

		\subsection{Décomposition des éléments de l'ordonnanceur}
			\subsubsection{Vue générale}
			\begin{figure}[!ht]
			    \centering
			    \input{figures/scheduler_overview.tex}
			    \caption{Overview of the scheduler components and their interactions}
			    \label{fig:project_overview}
			\end{figure}


			La figure \ref{fig:project_overview} donne une vue générale des composants de l'ordonnanceur et de leurs interactions. Le \emph{back-end} est le point d'entrée de l'ordonnanceur. Il est appelé par le noyau lorsqu'une interruption survient, appelle la fonction d'élection puis exécute le \emph{job} choisi par la fonction d'élection. Le \emph{back-end} doit aussi mettre à jour une partie de l'état sur laquelle repose la fonction d'élection, que nous appelons l'environnement. L'environnement est la partie de l'état disponible en lecture seule à la fonction d'élection, que la fonction d'élection peut interroger au travers des \emph{oracles}. La seconde partie est la partie mutable de l'état, que la fonction d'élection ne peut manipuler qu'au travers de l'\emph{interface}, principalement composée de types de données et de fonction pour les manipuler.

		\subsubsection{État interne de l'ordonnanceur}

			L'état interne de l'ordonnanceur est chargé de stocker les informations nécessaires à la fonction d'élection pour calculer le prochain \emph{job} à élire. Il existe deux représentations de cet état : une implémentation exécutable, et un modèle utilisé pour la preuve.

			L'état est -- de sucroit -- divisé en deux parties, qui se distinguent par leur fonction par rapport à la fonction d'élection. La première partie de l'état est maintenue par la fonction d'élection, qui peut y lire et y écrire des données à sa guise en utilisant l'interface de l'état prévue à cet effet. Cette partie de l'état est appelée l'état mutable. La seconde partie est la partie de l'état que la fonction d'élection ne peut qu'observer, qui est appelé l'environnement. L'environnement contient les informations relatives aux évènements extérieurs essentiels au bon fonctionnement de l'ordonnanceur, tels que l'arrivée de nouveaux \emph{jobs} à ordonnancer, ou la complétion d'un \emph{job} précédemment exécuté. Cette partie de l'état est donc accessible en lecture seule à la fonction d'élection. La fonction d'élection peut consulter l'environnement aux travers d'oracles, qui servent d'interface avec l'environnement.

		\subsubsection{Interface avec l'état (types abstraits et oracles)}
			
			Comme indiqué dans la sous-section précédente, la fonction d'élection effectue des modifications sur l'état ou observe l'environnement grâce à l'interface et aux oracles. Cette interface est \emph{nécessaire} car elle permet de définir les opérations qui doivent être supportées par l'état, et donc par ses deux représentations (le code exécutable et le modèle). Sans cette interface, certaines opérations pourraient être possible dans une des deux représentations sans qu'elle soit possible dans l'autre.
			L'interface ainsi que les oracles sont composés de types opaques, implémentés de manière indépendante dans les modèles ou dans le code exécutable. Ces types sont munis de fonctions elles aussi pourvues d'une implémentation exécutable ainsi que d'un modèle.

			Les oracles sont une partie de l'interface spécifique. Les oracles sont la partie de l'interface qui permet à la fonction d'élection d'observer les phénomènes extérieurs qui lui sont extérieurs, plsu précisément la terminaison du \emph{job} précédemment exécuté et la liste des nouveaux \emph{jobs} à ordonnancer. Bien qu'ils disposent aussi de deux représentations, leur modèle ne décrit pas réellement les résultats que l'oracle doit produire, mais plutôt des contraintes sur les résultats produits. Le modèle va se contenter de décrire l'ensemble des résultats possibles, plutôt que d'en désigner un en particulier. Par exemple, une des contraintes sur la liste des nouveaux jobs est que leur date d'arrivée ne peut pas être supérieure à la date courante. 

		\subsubsection{Back-ends}
		\label{sec:back-ends}

		Nous avons vu que l'état est composé en partie d'une partie non mutable, appelée l'environnement. Les informations contenues dans l'environnement sont mises à jour par le \emph{back-end}. Le \emph{back-end} est aussi chargé d'appeler la fonction d'élection et d'exécuter le \emph{job} qui aura été élu.

		Cette contribution est munie de deux \emph{back-ends}.
		\begin{itemize}
			\item Le premier back-end est conçu comme une simulation permettant d'exécuter la fonction d'élection dans un simple processus Linux, afin de fournir des informations sur l'état interne de l'ordonnanceur. Ce back-end appelle la fonction d'élection, affiche le \emph{job} choisi pour exécution et autres informations d'intérêt sur l'état interne de la fonction d'élection tels que la liste des \emph{jobs} en attente, etc ;

			\item Le second back-end fourni est l'implémentation d'un ordonnanceur Earliest Dealine First dans une partition de Pip. Cette implémentation exécute la fonction d'élection et transfère le flôt d'exécution vers le \emph{job} élu par la fonction d'élection. Chaque job se trouve dans sa propre partition, avec un espace d'adressage qui lui est propre. Le flôt d'exécution revient au back-end soit lorsqu'une interruption d'horloge survient, interrompant le \emph{job} élu, soit lorsque le \emph{job} lui signale sa terminaison. Le back-end attend alors la prochaine interruption pour réélire un nouveau \emph{job}.
		\end{itemize}

		Les back-ends ne font pas partie du modèle mathématique de l'ordonnanceur, si ce n'est au travers des \emph{oracles}. Ils ne font pas partie de la politique d'ordonnancement ; ils appliquent simplement ses arbitrages et lui fournissent les informations dont elle a besoin.

		\subsubsection{Fonction d'élection}

		La fonction d'élection est divisée en deux parties principales. La première partie maintient la liste des \emph{jobs} en attente et sélection le prochain \emph{job} à exécuter, la seconde maintient la cohérence de son état interne.

		Dans la première partie, la fonction d'élection invoque un oracle, qui lui retourne la liste des nouveaux \emph{jobs} à ordonnancer. Ces jobs sont ajoutés à la liste des jobs à ordonnancer. Ensuite, elle invoque un autre oracle qui lui renvoie l'état du dernier job exécuté, afin de vérifier s'il a complété son exécution ou s'il a dépassé son échéance. S'il remplit l'une de ces deux conditions, il est enlevé de la liste des jobs à ordonnancer. Si il a excédé son échéance, l'erreur sera remontée lors du retour de la fonction. Enfin, la fonction récupère l'identifiant du premier \emph{job} de la liste (si la liste n'est pas vide) et le retourne avec le drapeau indiquant si le dernier \emph{job} exécuté a dépassé son échéance. Une valeur par défaut est retournée si aucun \emph{job} n'est disponible.

		La seconde partie de la fonction d'élection maintient la cohérence de l'état interne de la fonction d'élection pour les futurs appels. Elle commence par décrémenter le budget d'exécution du \emph{job} élu. Elle décrémente ensuite l'échéance relative des \emph{jobs} en attente, pour tenir compte du temps qui sera passé à exécuter le \emph{job} élu. Finalement, la fonction d'élection incrémente le compteur de temps, qui garde le compte de périodes de temps s'étant écoulées depuis le premier appel à la fonction d'élection.

	\section{Conduite de la preuve}

	\label{sec:proof}
	Cette section met en avant la preuve fonctionnelle de la fonction d'élection de l'ordonnanceur EDF, écrit sous la forme d'un programme monadique dans l'assistant de preuve Coq.

	Cette section commencera par décrire la méthodologie de preuve, qui utilise un raffinement en 3 niveaux d'abstraction. La section décrira ensuite les différents niveaux d'abstraction et le raffinement qui les relie, en détaillant particulièrement pourquoi le raffinement préserve les propriétés de correction du niveaux d'abstraction supérieur. Enfin, la section conclura sur quelques détails d'élaboration de la preuve en Coq.

	\subsection{Méthodologie de preuve}

	Cette preuve est conduite par raffinement. Cette méthode permet d'appliquer la stratégie "diviser pour régner" pour gérer la complexité de la preuve.
	Cette preuve commence par une définition abstraite de la politique d'ordonnancement Earliest Deadline First, et montre que la politique est \emph{correcte}. Cette étape signifie que, sous réserve de quelques hypothèses, n'importe quel ensemble de \emph{jobs} ordonnançable ordonnancé selon cette politique sera ordonnancé tel que chaque \emph{job} complètera son exécution sans excéder son échéance.
	La preuve continue en définissant un algorithme de fonction d'élection idéalisé, et montre que cet algorithme implémente la politique d'ordonnancement définie précédemment. Il suit que l'algorithme idéalisé est aussi \emph{correct}.
	L'étape finale de la preuve consiste à écrire la fonction d'élection qui sera finalement compilée en code source C. Il faut ensuite montrer que la fonction d'élection qui sera traduite en C exhibe les mêmes comportements que l'algorithme idéalisé de la fonction d'élection (en particulier les effets de bord et les valeurs de retour). La preuve est alors complète, la preuve de correction a été propagée jusqu'au code C.
	%The properties proved in our work act as layered invariants that extend from the EDF policy model to the monadic code. To prove a new refinement layer, we start from the invariant of the previous (more abstract) layer and show that the new invariant \emph{refines} the previous one, i.e., the new invariant has a more detailed specification that remains compatible with its more abstract version.
	%All the proofs that we performed rely on the following assumptions.

	\subsubsection{Modèle de \emph{job}}
	\label{sec:jobmodel}
	Les \emph{jobs} sont modélisés comme des tuples $j = (i_j, r_j,d_j,c_j, \delta_j)$ d'entiers naturels, où $i_j$ est l'identifiant du \emph{job}, $r_j$ représente l'instant à partir duquel il est possible de l'ordonnancer (\emph{release date}), $d_j$ représente son échéance (\emph{deadline}), et $c_j$ représente son budget temporel, qui est une borne supérieure sur sa durée d'exécution. $\delta_j$ représente sa durée d'exécution maximum réelle (Worst Case Execution Time -- \emph{WCET}).

	Les \emph{jobs} doivent respecter certaines contraintes de construction :
	\begin{itemize}
		\item $r_i + c_i \leq d_i$, l'échéance est assez tardive pour que le \emph{job} puisse terminer son exécution sans la dépasser s'il est le seul à s'exécuter sur le processeur ;
		\item $0 < \delta_j \leq c_j$, le budget temporel alloué est bien une borne supérieure au temps d'exécution maximum réel (WCET), lui-même strictement positif ;
		\item l'identifiant de chaque \emph{job} doit être unique ;
		\item il n'existe qu'une seule occurrence de chaque \emph{job}.
	\end{itemize}

	\subsubsection{Hypothèse d'ordonnançabilité}

	Soient deux instants quelconques $t$ et $t'$ tels que $t < t'$, soit $\Gamma_{t, t'}$ l'ensemble des \emph{jobs} à ordonnancer dans l'intervalle $[t, t']$ (c'est à dire les \emph{jobs} $j$ ayant une release date $r_j$ supérieure à $t$ et une échéance $d_j$ inférieure à $t'$).
	L'hypothèse d'ordonnançabilité stipule que la somme des durées $\delta_j$ des \emph{jobs} à ordonnancer dans l'intervalle $[t, t']$ est inférieure à la durée $t'-t$ de l'intervalle.

	\begin{gather} \label{eq:schedulability}
    		\forall t, t'. ~t < t' \implies
    		\sum_{j \in \Gamma_{t, t'}}\delta_j \leq t' - t
	\end{gather}
%% \text{with:}
%% \begin{align*}
%%               \rho, \delta&\text{, arbitrary time instants},\\
%%               \Gamma_{\rho, \delta}&\text{, the set of jobs to schedule in the interval $[\rho, \delta]$},\\
%%               J_i&\text{, a job from }\Gamma_{\rho, \delta},\\
%%               r_i,~d_i,~C_i &\text{, respectively the release time, the deadline,}\\&\text{~~and the WCET of }J_i
%% \end{align*}
	Le fait qu'un ensemble de jobs ordonnançable puisse être ordonnancé par un ordonnanceur Earliest Deadline First sur un unique processeur est un résultat classique de la théorie de l'ordonnancement (\cite{stankovic2012deadline}, pp. 33-34). Les conditions d'ordonnançabilité d'un ensemble peuvent parfois être représentées plus simplement, par exemple lorsque les \emph{jobs} sont des instances de tâches périodiques. Cependant cette contribution porte sur un ordonnanceur de \emph{jobs arbitraires}, ce qui ne nous permet pas d'utiliser les hypothèses d'ordonnançabilité de cas spécifiques.

	\subsection{Couches d'abstraction et étapes de raffinement}

	\subsubsection{Politique d'ordonnancement Earliest Deadline First}
	\label{sec:policy}
	La première couche d'abstraction, la plus abstraite de toutes, est celle de la politique d'ordonnancement. Elle est définie de la manière suivante : pour tout \emph{job} $j$, et à n'importe quel instant $t$, si le \emph{job} $j$ s'exécute à l'instant $t$, alors pour chaque autre \emph{job} $j'$ qui aurait pu être exécuté à la place, on a $d_j \leq d_{j'}$.

	De manière formelle,
	\begin{equation*}
		\forall j, \forall t, [...]~\mathtt{run}~j~t~~\implies~~\forall j',~\mathtt{waiting}~j'~t~~\implies~~d_j \leq d_{j'}.
	\end{equation*}
\indent avec :
	\begin{align*}
		j, j'&\text{, deux identifiants de job},\\
		t&\text{, un instant arbitraire},\\
		\mathtt{run}~i~t&\text{, prouvable si le \emph{job} $j$ s'exécute à l'instant $t$},\\ 
		\text{waiting}~x~t&\text{, prouvable si le \emph{job} $j'$ est prêt à s'exécuter à l'instant $t$}
	\end{align*}

	La \emph{propriété de correction} pour la politique d'ordonnancement EDF est décrite de la manière suivante.
	Étant donné un ensemble ordonnançable de \emph{jobs} (c'est à dire satisfaisant l'hypothèse d'ordonnancement \ref{eq:schedulability}), si la politique d'ordonnancement EDF est appliquée, alors aucun \emph{job} de l'ensemble ne dépassera son échéance.
	
	\begin{gather*}
		\textit{ordonnançable} \implies\\
  		\forall j, \forall t.~~~\text{EdfPolicyUpTo}~t \implies\\
		\neg \text{overdue}~j~t.
	\end{gather*}
\indent	avec :
	\begin{align*}
		\text{EdfPolicyUpTo}~t&\text{ signifie que la politique a été appliquée jusqu'à l'instant}~t\\
		\text{overdue}~j~t&\text{, prouvable si le \emph{job} $j$ a dépassé son échéance à l'instant}~t
	\end{align*}

	\subsubsection{Fonction d'élection idéalisée implémentant la politique d'ordonnancement}
	\label{sec:functional}

	La première étape du raffinement est de montrer que la fonction d'élection idéalisée \texttt{functional\_scheduler\_star} implémente la politique d'ordonnancement EDF. La propriété suivante établie que si la fonction d'élection idéalisée est exécutée jusqu'à un certain instant $t$, alors la politique EDF a été appliquée jusqu'à cet instant.
	\begin{gather*}
		\forall t, \forall o, \forall s.~~~\texttt{functional\_scheduler\_star}~(t) = (o,s) \implies\\
		\text{EdfPolicyUpTo}~(\text{now}~s).
	\end{gather*}
\indent	avec :
	\begin{align*}
		s&\text{, l'état du programme après avoir exécuté la fonction}\\
		&~~\text{d'élection idéalisée après $t$ unités de temps},\\
		%\texttt{functional\_scheduler\_star}~(t)&\text{, appel à la fonction d'élection idéalisée pour $t$ unités de temps}\\
		\text{now}~s&\text{, extrait le compteur d'unité de temps de l'état $s$}\\
		o~&\text{, l'identifiant du \emph{job} élu à l'instant $t$}
	\end{align*}

	De cela, on peut déduire la propriété de correction de la fonction d'élection idéalisée :
	étant donné un ensemble de \emph{job} ordonnançable, alors pour tout \emph{job} $j$ de cet ensemble, ce \emph{job} ne dépassera pas son échéance à l'instant $t$ si la fonction a été appelée à chaque instant jusqu'à l'instant $t$

	\begin{gather*}
		\textit{ordonnançable} \implies\\
		\forall t, \forall o, \forall s.~~~\texttt{functional\_scheduler\_star}~(t) = (o,s) \implies\\
		\forall i.~~~\neg \text{overdue}~i~(\text{now}~s).
	\end{gather*}

	\subsubsection{Fonction d'élection monadique raffinant la fonction d'élection idéalisée}
	\label{sec:monadic}

	La prochaine étape consiste à prouver que la fonction d'élection monadique raffine la fonction d'élection idéalisée. Cette propriété contient des triplets de Hoare. 
	Les préconditions de la propriété sont paramétrés par un environnement observable \texttt{env} et par un état mutable $s$. Les postconditions sont paramétrées par la valeur de retour $o$ du programme $x$, et un état $s'$, le résultat de l'exécution du programme $c$ sur l'état $s$.

	Cette étape de raffinement peut être décrite de la manière suivante : pour tout instant $t$, si $(o, s')$ sont les valeurs retournées par la fonction d'élection monadique \texttt{scheduler\_star} sur l'environnement $E$ et l'état initial \texttt{init}, alors $(o, s')$ sont aussi les valeurs retournées par la fonction d'élection idéalisée \texttt{functional\_scheduler\_star} à l'instant $t$. Le triplet de Hoare correspondant est le suivant :
	\begin{gather*}
		\forall t.\\
		\{
		~\lambda~\mathtt{env}~s.~~~\mathtt{env} = E~~\land~~s = \mathtt{init}~
		\}\\
		\texttt{scheduler\_star}~(t)\\
		\{
		~\lambda~o~s'.~~~\texttt{functional\_scheduler\_star}~(t) = (o,s')~
		\}
	\end{gather*}

	À partir de ce triplet, on peut déduire le triplet de Hoare exprimant la propriété de correction de la fonction d'élection monadique.

	\begin{gather*}
		\textit{ordonnançable} \implies\\
		\forall t.\\
		\{
		~\lambda~\mathtt{env}~s.~~~\mathtt{env} = E~~\land~~s = \mathtt{init}~
		\}\\
		\texttt{scheduler\_star}~(t)\\
		\{
		~\lambda~\_~s'.~~~\forall i.~~~\neg \text{overdue}~i~(\text{now}~s') ~
		\}
	\end{gather*}


	\subsection{Articulation de la preuve en Coq}

	\textcolor{red}{Les détails de la preuve sont disponibles sur le dépot, mais ici nous allons développer les faits saillants de cette preuve}

	Our Coq proofs closely follow the top-down refinement approach outlined above. First, the job model, mathematically described in Section~\ref{sec:jobmodel}, is encoded in Coq. The assumptions listed in~\ref{sec:jobmodel} (specifically: each deadline is large enough for a job to complete its execution when running alone on the processor; job durations are greater than zero and are over-approximated by the respective budgets; identifiers uniquely determine jobs; and every job is released exactly once) are global assumptions of the proof. Arguably, the global assumptions are just reasonable well-formedness constraints.



	At the highest abstraction level (EDF policy) there are additional \emph{local} assumptions.
	The local assumptions are only used in the proof of correctness of the EDF scheduling policy. When the policy is subsequently
	refined into an algorithm the local assumptions disappear - they become Coq definitions and lemmas.
	Two abstract functions are locally assumed: \texttt{run}, which determines which job (if any) is  running at a given moment, and \texttt{rem}, that keeps track of the remaining execution time for any given job and at any given moment.
	The following facts are also locally assumed about these functions, which model general facts about monoprocessor scheduling:
	
	\begin{itemize}
		\item at any moment in time, at most one job is running;
		\item up to and including its release time, the remaining execution time of a job equals its duration;
		\item the remaining execution time of a job decreases when the job is running, and stays constant otherwise;
		\item whenever there is at least a released job with non-zero remaining execution time, there is one job that is running.
	\end{itemize}

	Under the said local assumptions the correctness proof of the EDF policy is mostly a matter of algebraic calculations. It is relatively short: $\sim$1000 lines, mostly due to the fact that at this abstraction level one can focus on the essentials, without having to deal with implementation details.

	The first refinement step, from EDF policy to EDF functional scheduler, amounts for the largest part of the proof effort. Essentially, this is because there is a substantial abstraction gap between the EDF policy level, which is written in relatively simple algebraic terms, and the functional-scheduler level, which encodes the policy in terms of a rather detailed list data structure. The refinement consisted in defining concrete versions of the abstract functions locally assumed at the EDF policy level - \emph{run} and \emph{rem} - in terms of the said list structure, and in proving the properties relating these functions, which at the EDF policy level were locally assumed. Once this is done, the correctness of the EDF functional algorithm is a simple conjunction between the correctness of the EDF policy and the fact that the function scheduler implements the policy. Proving an implementation relation instead of the global correctness property on the functional scheduler is easier, since the proof obligations for the implementation relation are more detailed than the global correctness property: there are fewer details that need to be "filled in" by additional proofs.

	All the properties to be proved are invariants - predicates that hold at all states reachable from an initial state, obtained by executing the functional scheduler any finite number of times. The proof required us to discover additional \emph{inductive} invariants, which hold initially and whose truth is preserved by each execution of the scheduler. Such invariants have to be chosen so that together they imply the original invariant. This is where creativity is required from the user. Together with the functional scheduler this step amount to $\sim$1600 lines of code.

	By comparison, the second (and last) refinement step is short ($\sim$500 lines). It amounts to proving that, starting from a given initial state, the reachable states generated by running the monadic EDF scheduler are included in the states generated by running the functional EDF scheduler. This was relatively easy (especially compared to the first refinement step) because the functional and monadic schedulers are relatively close in terms of abstraction level; e.g., they work with the same data structures. The difference lies in the fact that the functional scheduler computes in one large step what the monadic one computes in a sequence of many small steps.  The functional algorithm is not subject to such requirements, thus, it is free to "compact" a long sequence of small steps into a large single step. By doing so the functional scheduler also saves us from the effort of proving even more additional invariants, about intermediary states that the monadic scheduler generates.  
\indent The global conclusion that the monadic EDF scheduler is correct follows from the correctness of the abstract EDF policy and the correctness of the two successive refinements.

	\section{Mise en oeuvre / Implémentation}
		\subsection{Dualité implémentation/modélisation}
			% Méthode générale
		
		\subsection{Implémentation vue comme un cas particulier de l'interface abstraite}
	\label{sec:monad}

	In this section we detail how the interface of the verified code - the monad - is designed. The monad is simply a specification of how the interface should behave. We also explain the differences between the monad's model and its actual implementation.
	The various parts are represented in Figure \ref{fig:project_overview}.

	We start by detailing the verified code's internal state, which is composed of two parts: a read-only part that we call the environment, and a mutable part. Then, we introduce a model-blind software that computes the information held in the environment, that we call the back-end. Next, we  explain how the verified code can retrieve the information from the environment. Finally, we give details about the interface that allows the verified code to interact with the mutable part of the state.

	\subsection{Program state}

	The state model is divided into two parts: a part containing the values over which the algorithm has no control, its \emph{environment}, which is immutable. These values are provided by the back-end. The second part of the model contains the values over which the algorithm has control and which are therefore mutable.

	The environment is defined as a function that, given a certain timestamp, returns a list of jobs to add to the pending jobs list.
	%\begin{verbatim}
	\begin{minted}{coq}
Definition Env : Type := CNat -> list Job.
	\end{minted}
	%\end{verbatim}

	The mutable state model consists of structure with two fields. The first is simply a time counter and the other is a list of \emph{entries}. Entries are structures that associate jobs with their remaining time budget and relative deadline. The state is therefore defined as follows:
	%\begin{verbatim}
	\begin{minted}{coq}
Record State := 
mk_State {
    now : CNat ;
    active : list Entry ;
}.
	\end{minted}
	%\end{verbatim}

	The resulting state model, composed of both mutable and immutable parts, has the following type:
	%\begin{verbatim}
	\begin{minted}{coq}
Definition RT (A : Type) : Type :=
    Env -> State -> A * State.
	\end{minted}
	%\end{verbatim}

	We now describe how the state is implemented.
	The implementation takes advantage of the fact that the election function creates a single structure for each job. Essentially, the implementation reserves additional memory space for each job to be scheduled, which the algorithm uses to store the related Entry structure.

	Thus, there is an array of \texttt{coq\_N} elements (where \texttt{coq\_N} is the static upper bound on the number of jobs to be scheduled) that contains the initial immutable information about the pending jobs, as well as the additional mutable memory that the algorithm needs. The jobs are identified by their own index in this array. Each element of this array also contains two additional memory words. These memory bits are used to maintain the various lists required by the algorithm: the list of newly available jobs to be scheduled from the environment and maintained by the back-end, and the list of jobs pending execution from the internal state of the program, maintained by the algorithm).

	So this large array has elements of type:
	%\begin{verbatim}
	\begin{minted}{c}
typedef struct __internal_s__ {
    struct __internal_job__   job;
    struct __internal_entry__ entry;
    int jobset_next_job_index;
    int active_next_entry_index;
} internal_t;
	\end{minted}
	%\end{verbatim}

	The overall state of the program consists of this big array, the heads for the two different lists, the clock counter variable from the mutable state, and a variable that indicates whether the last job completed its execution (which is manipulated by the back-end):

	%\begin{verbatim}
	\begin{minted}{c}
internal_t INTERNAL_ARRAY[coq_N] = EXAMPLE_JOB_SET;

int JOBS_ARRIVING_HEAD_INDEX = -1;
int ACTIVE_ENTRIES_HEAD_INDEX = -1;

unsigned int CLOCK = 0;
coq_CBool  JOB_DONE = false;
	\end{minted}
	%\end{verbatim}

	\subsection{Oracles}

	There are two oracle primitives that return values managed by the back-end code and abstract to the model. The first, \texttt{jobs\_arriving}, retrieves the new jobs that need to be added to the pending job list; the other, \texttt{job\_terminating}, returns whether the last executed job completed its execution (if such a job exists). \footnote{Their model is available in \texttt{src/coq/model/Interface/Oracles.v}, while their C interface implementation can be found in \texttt{src/interface\_implementation/include/Primitives.h}.}

	The monadic code can retrieve the identifiers of incoming jobs via an oracle that reads the environment. The model imposes a single constraint on the implementation: in the list of job identifiers returned by the oracle, no identifier may be greater than $N$, where $N$ is a predefined static upper bound. 

	%\begin{verbatim}
	\begin{minted}{coq}
Definition jobs_arriving (N : nat) : RT JobSet :=
  fun env s =>
    let f :=  List.filter
      (fun j =>  Nat.ltb j N)
      (map jobid (env s.(now))) 
  in (f, s).
	\end{minted}
	%\end{verbatim}

	We would like to draw the reader's attention to the fact that the model is \textbf{purely abstract}; it does not indicate which jobs are ready for execution, since the scheduling algorithm does not rely on this information. Also note that the list of identifiers is hidden behind the abstract type \texttt{JobSet}.

	In contrast, the implementation of the function that returns the oracle's prediction is quite simple:

	%\begin{verbatim}
	\begin{minted}{c}
static inline coq_JobSet
Primitives_jobs_arriving(coq_CNat n) {
     return JOBS_ARRIVING_HEAD_INDEX;
}
	\end{minted}
	%\end{verbatim}

	The implementation simply reads the index of the first arriving job from the environment. The list of incoming jobs is previously created by the back-end, so the actual list creation process depends on the back-end.

	The other oracle is a function that returns whether the job with the most critical deadline (at the head of the list maintained by our scheduler) has completed its execution. The model is stricter with this oracle. It forces the implementation to return \texttt{True} if time spent executing the job is greater than its theoretical WCET.

	\vspace{1cm}

	Here is the (nested) model definition:

	%\begin{verbatim}
	\begin{minted}{coq}
Definition job_terminating : RT CBool :=
fun _ s => ((
    match head s.(active) with
    | None => false
    | Some e =>
        let j := Jobs (e.(id)) in
        Nat.leb e.(cnt) (j.(budget) - j.(duration))
    end
), s).
	\end{minted}
	%\end{verbatim}

	Note that the counter \texttt{e.(cnt)} is decremented from an initial value of \texttt{j.(budget)} each time the job is scheduled for execution. 

	Like the previous oracle, the implementation that returns the result of the oracle is very simple:

	%\begin{verbatim}
	\begin{minted}{c}
static inline coq_CBool Primitives_job_terminating(void) {
    return JOB_DONE;
}
	\end{minted}
	%\end{verbatim}

	The implementation only returns the variable \texttt{ JOB\_DONE} from the internal state. This variable is updated by the back-end when needed.

	We now review the software that allows the verified code to interact with the mutable state.

	\subsection{Abstract Types}

	All types used by the verified code are abstract types (black box types). These types have their own interface. 

	There are abstract types for Boolean values, integers, read-only job structures, and read-write job structures. Most of the primitives are simple and straightforward functions for specific data types. For example, there are 3 primitives for the boolean type \texttt{CBool} : \texttt{not}, \texttt{and}, and \texttt{or}.
	Here one can see the model of type CBool together with the boolean primitive \texttt{or}:

	%\begin{verbatim}
	\begin{minted}{coq}
Definition CBool := bool.

Definition or (b1 b2 : CBool) : RT CBool :=
  ret (orb b1 b2).
	\end{minted}
	%\end{verbatim}

	The actual implementation is defined as follows:

	%\begin{verbatim}
	\begin{minted}{c}
typedef int coq_CBool;

static inline coq_CBool CBool_or(coq_CBool b1, coq_CBool b2) {
    return b1 || b2;
};
	\end{minted}
	%\end{verbatim}

	Mutable structures such as type \texttt{Entry} are given primitives for creating the structure and for accessing and modifying their fields. In the same fashion, read-only data structures are only given access primitives. For example, the type \texttt{JobSet} returned by the oracle \texttt{jobs\_arriving} has only three primitives : one to check for emptiness of the set, another to get the first \texttt{Job}, and a final one to get the remaining \texttt{Jobs}. The \texttt{Job} type only has primitives that return the fields of the structure. \footnote{All model definitions for these types are available in the \texttt{src/coq/model/Interface/Types} directory.}


	Finally, there is another set of eight primitives that interact directly with the internal state of our program. The program needs to manage a counter to keep track of time. For this, we have two primitives, a getter and a setter for the counter.

	These functions are trivially modeled and implemented:

	%\begin{verbatim}
	\begin{minted}{coq}
Definition get_time_counter
: RT CNat :=
  fun _ s => ((now s), s).

Definition set_time_counter
(counter : nat) : RT unit :=
  fun _ s => (tt,
    {|
      now    := counter ;
      active := (active s) ;
    |}
  ).
	\end{minted}
	%\end{verbatim}

	%\begin{verbatim}
	\begin{minted}{c}
static inline coq_CNat
State_get_time_counter(){
    return CLOCK;
};

static inline void
State_set_time_counter(coq_CNat counter){
    CLOCK = counter;
};
	\end{minted}
	%\end{verbatim}
	The scheduler also needs to maintain a list of pending jobs. It consists of six primitives, including one primitive that determines whether jobs are present in the list, and another that returns the ID of the job located at the head of the list (if any). Two other primitives respectively add a new job to the list (in sorted form) and remove the first job from the list. The last two primitives are meant to update job structures: either just the first job or the entire list. \footnote{Their model are in the \texttt{src/coq/model/Interface/Types/State.v} file, while their implementation are in the \texttt{src/interface\_implementation/State.c} file. (The simplest ones are inline functions located in the corresponding header).}

	\begin{figure*}[!ht]
	    \centering
	%    \begin{verbatim}
	    \begin{minted}{coq}
Definition insert_new_active_entry (entry : Entry)
           (comp_func : Entry -> Entry -> CBool) : RT unit :=
  fun _ s => (tt, {|
    now := now s ;
    active := (insert_Entry_aux entry (active s) comp_func);
  |}
).

Fixpoint insert_Entry_aux (entry : Entry) (entry_list : list Entry)
         (comp_func : Entry -> Entry -> CBool) : list Entry :=
  match entry_list with
  | nil => cons entry nil
  | cons head tail =>
      match comp_func entry head with
      | true => cons entry (cons head tail)
      | false => cons head (insert_Entry_aux entry tail comp_func)
      end
  end.
	    \end{minted}
	%    \end{verbatim}
	    \vspace{0.2cm}
	    \hrule
	    \vspace{0.2cm}
	%    \begin{verbatim}
	    \begin{minted}{c}
void State_insert_new_active_entry
     (coq_Entry entry, entry_cmp_func_type entry_comp_func) {
  int *entry_index_ptr = &(ACTIVE_ENTRIES_HEAD_INDEX);
  int next_index = -1;
  while (*entry_index_ptr != -1) {
    if (entry_comp_func(entry, &(INTERNAL_ARRAY[*entry_index_ptr].entry))) {
      next_index = *entry_index_ptr;
      break;
    }
    entry_index_ptr = &(INTERNAL_ARRAY[*entry_index_ptr].active_next_entry_index);
  }
  *entry_index_ptr = entry->id;
  INTERNAL_ARRAY[entry->id].active_next_entry_index = next_index;
}
	    \end{minted}
	%    \end{verbatim}
	    \caption{Side by side comparison between the model of a sorted list insertion primitive and its actual implementation}
	    \label{fig:model_impl_cmp}
	\end{figure*}

	Most of these primitives are both simple to model and implement, but two of them are not so easy to implement. The first one is \texttt{insert\_new\_active\_entry}, which inserts an entry (an internal representation of a job to execute) sorted by an arbitrary comparison function. Its model is given in the first half of Figure \ref{fig:model_impl_cmp}.

	Given an entry and a comparison function, this model extracts the list from the current state of the program. It passes it to a (non-monadic) auxiliary recursive function that returns the list with the newly inserted entry.

	This helper function then constructs a completely new list by comparing each entry from the list with the new list, using the comparison function from the parameters. 

	Of course, one can not afford to copy the list every time an item is inserted. The implementation uses in-place insertion in the list. The interface chosen to interact with the state prevents a mismatch between the model and reality, where one creates new lists while the other modifies the list in-place.

	This code is conceptually the same as the recursive functional version, but uses loops and updates the required links between elements when a new element is inserted, rather than creating new elements and cleverly rearranging them.

	The same technique was used to model and implement the function \texttt{update\_active\_entries}, which applies an arbitrary modification to each entry in the list. The implementation modifies the elements of the list in-place rather than creating a new list with modified copies of entries.

	\label{sec:implementation}

	We argue that all the primitives described in this section are simple enough to trust that the implementation actually conforms to the model. Nevertheless, the last two primitives are arguably complex enough to shake this confidence. We discuss this point further in Section \ref{sec:discussion}.

	\section{Discussion sur la méthodologie suivie}
		\subsection{Métriques}
		\subsection{Choix des primitives}
