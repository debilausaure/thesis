\chapter{Politique d'ordonnancement prouvée}

	\section{Motivations}
	% Intro : ce qu'on va étudier : utliser notre méthode de dévelopement de logiciel pour prouver un algorithme de selection des cibles du transfert de flot d'exécution
	% Préemption n'est pas la politique
	% Autre type de preuve : garantir le respect des échéances / pourquoi est ce vraiment critique ?
	% Différence algorithme / imlplémentation de l'algorithme

		\subsection{Objet de preuve}
		% Description informelle des propriétés
	

	\section{Description structurelle}

		\subsection{Définition prototype et oracle}

		\subsection{Place de l'ordonnancement dans Pip}
			\subsubsection{Ordonnancement dans une partition}
			\subsubsection{Positionnement par rapport à un système d'exploitation grand public}
				% Ne pas avoir à prouver les propriétés de sécurité demandées par du code noyau
				% ordonnanceur et méthodologie sont agnostiques du système d'exploitation

		\subsection{Décomposition des éléments de l'ordonnanceur}
			\subsubsection{Vue générale}
			\subsubsection{Fonction d'élection}
			\subsubsection{État}
			\subsubsection{Interface avec l'état (monade et oracles)}
			\subsubsection{Back-end}

		
	\section{Conduite de la preuve}
		% section 5 de l'article

	\section{Mise en oeuvre / Implémentation}
		\subsection{Dualité implémentation/modélisation}
			% Méthode générale
		
		\subsection{Implémentation vue comme un cas particulier de l'interface abstraite}
			%section 4 du papier

	\section{Discussion sur la méthodologie suivie}
		\subsection{Métriques}
		\subsection{Choix des primitives}
