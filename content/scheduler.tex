\chapter{Politique d'ordonnancement prouvée}

	Le chapitre précédent a porté sur un service de transfert de flôt d'exécution au sein de Pip. Ce service permet de gérer les transferts explicites de flôt d'exécution, ainsi que les interruptions. De cette manière, Pip fournit les outils nécessaires à la préemption de flôts d'exécution. La préemption est nécessaire à la mise en place d'ordonnancement au sein d'un système ; elle n'est cependant pas suffisante pour implémenter un ordonnanceur. Celui-ci doit être muni d'une politique d'ordonnancement, lui permettant de choisir le prochain flôt d'exécution.

	Ce chapitre porte sur l'implémentation d'un ordonnanceur Earliest Deadline First (abrégé EDF) s'exécutant en espace utilisateur. L'ordonnanceur est conçu pour fonctionner dans une partition de Pip, et est muni d'une preuve formelle que sa fonction d'élection respecte la politique d'ordonnancement EDF. Ces travaux ont été menés conjointement avec Vlad Rusu, avec qui j'ai conçu les modèles sur lesquels reposent la preuve et qui a établit les preuves formelles sur cet ordonnanceur. Dans ce travail commun, ma contribution a été de concevoir les composants de l'ordonnanceur, leur interface ainsi qu'une partie de leur modèle, ainsi que d'écrire l'implémentation pour que cet ordonnanceur puisse être compilé et s'exécuter dans une partition de Pip.
	\footnote{David Nowak, Gilles Grimaud mais aussi Samuel Hym ont aussi contribué à ce projet de manière plus modeste. David a participé à l'élaboration des modèles, Gilles a participé à l'établissement des interfaces, et Samuel a participé à l'écriture de l'implémentation}.
	
	Ces travaux ont fait l'objet d'une publication et d'une présentation à RTAS2022, dont ce chapitre s'inspire fortement. Le papier est disponible à l'adresse suivante : \url{https://hal.archives-ouvertes.fr/hal-03671598}. La vidéo de la présentation est disponible à l'adresse suivante : \url{https://pip.univ-lille.fr/recordings/RTAS.mp4}. Le dépot contenant le code ainsi que les instructions pour exécuter l'ordonnanceur est hébergé sur Github : \url{https://github.com/2xs/pip_edf_scheduler}.

	\section{Motivations}
	
	% Autre type de preuve : garantir le respect des échéances / pourquoi est ce vraiment critique ?
	La motivation première de cette contribution est de proposer des garanties supplémentaires aux garanties d'isolation classiques de Pip. Cette motivation nous a mené à nous intéresser aux problématiques des systèmes temps réel, et notamment sur le respect des échéances, car nous pensons que la vision de Pip peut être pertinente. La preuve formelle du respect de la politique d'ordonnancement est un premier pas vers des garanties temps réel dans l'écosystème de Pip.

	% Intro : ce qu'on va étudier : utliser notre méthode de dévelopement de logiciel pour prouver un algorithme de selection des cibles du transfert de flot d'exécution autres propriétés que l'isolation
	Cette contribution est aussi un moyen d'éprouver la méthode de développement des logiciels et preuves de Pip, en l'appliquant à un autre objet d'étude. On peut noter deux différences fondamentales entre Pip et cet ordonnanceur. La première est que Pip s'exécute en mode privilégié, contrairement à l'ordonnanceur qui s'exécute en espace utilisateur. Cette différence a des répercussions sur la conception des interfaces ; la dépendance à du code non prouvé est moins critique en espace utilisateur. Cette différence a aussi un impact implicite sur les preuves : la logique de Hoare n'est valable que lorsque l'état ne change pas entre deux instructions -- il faut donc s'assurer que les interruptions ne perturbent pas l'ordonnanceur. La seconde réside dans le fait que les propriétés prouvées sur l'ordonnanceur relèvent de l'ordre des propriétés fonctionnelles, c'est à dire qui décrivent le comportement de l'ordonnanceur. Les propriétés d'isolation de Pip traditionnellement prouvées au travers de cette méthode ne sont pas des propriétés fonctionnelles. Aussi, nous ne chercherons pas à établir des propriétés non-fonctionnelles sur la préemption telles que des propriétés sur le partage du temps d'exécution du processeur. Ces deux différences font de cet ordonnanceur un objet d'étude intéressant du point de vue du développement logiciel.

	De plus, cette contribution utilise tous les aspects du service de transfert de flôt d'exécution décrit dans le chapitre précédent. Cette contribution permet d'exhiber par l'expérience que l'utilisation de ce service est pertinente dans un composant commun de système d'exploitation.
	
	Enfin, cette contribution apporte une preuve inédite à la communauté des systèmes temps réels. En effet, les travaux montrant de manière formelle des propriétés sur les algorithmes d'ordonnancement sont fréquents dans la communauté. Néanmoins, peu de travaux s'intéressent à la preuve de \emph{l'implémentation} de l'algorithme, qui permettent par exemple de propager les preuves jusqu'au code compilé, et qui tiennent compte de détails supplémentaires (tels que les structures de données par exemple). Cette contribution fournit une preuve formelle que l'implémentation de la fonction d'élection respecte la politique d'ordonnancement EDF pour des \emph{jobs} arbitraires, ce qui n'avait été prouvé sur aucun autre ordonnanceur EDF auparavant. Des travaux indépendants et concomitants sur le projet CertiKOS ont montré une propriété similaire sur un ordonnanceur. Cependant leur ordonnanceur est limité à l'ordonnancement de \emph{jobs} provenant de tâches périodiques.

	\section{Description structurelle}

		Cette section décrit la structure générale de l'ordonnanceur. Elle commencera par sa partie phare, la fonction d'élection. Cette section en donnera une description fonctionnelle, ainsi que son prototype. Cette section décrira ensuite la place de l'ordonnancement dans Pip. Elle discutera du choix de placer l'ordonnanceur dans une partition, et des différences principales avec un système d'exploitation classique tel que Linux. Enfin, cette section détaillera les composants de l'ordonnanceur, leur fonction ainsi que leurs interactions.

		\subsection{Définition prototype et oracle de la fonction d'élection}

		La fonction d'élection est le morceau de logiciel que l'ordonnanceur doit appeler à chaque préemption, afin d'élire le prochain flôt d'exécution du système. La fonction d'élection fait ce choix en accord avec une politique d'ordonnancement qui lui permet de discriminer les flôts d'exécution selon des critères spécifiques qui sont propres à chaque politique. En particulier, la fonction d'élection de notre contribution suit la politique d'ordonnancement \emph{Earliest Deadline First}, qui est une politique temps réel dont la priorité est d'exécuter les \emph{jobs} dont l'échéance est la plus proche.

		La fonction d'élection de notre ordonnanceur agit comme un oracle, ne prennant aucun argument et retournant un type composite. Ce type composite contient un booléen indiquant à l'ordonnanceur qu'il doit attendre la prochaine préemption car il n'y a aucun \emph{job} à exécuter. Ce type contient l'identifiant du \emph{job} à exécuter dans le cas contraire, ainsi qu'un autre booléen indiquant si le \emph{job} a dépassé son échéance. Ce dernier booléen sert à informer l'ordonnanceur que l'ensemble des \emph{jobs} n'est pas ordonnançable.

		\begin{listing}[!ht]
			\coqcode{code/electionfunction.v}
			\caption{Prototype de la fonction d'élection et définition de son type de retour }
		\end{listing}

			\subsubsection{Exemple d'appel à la fonction d'élection}

			\textcolor{red}{décrire les figures, expliquer les jobs et le role de la fonction d'élection}

			\begin{figure}[!ht]
			\centering{
				\input{figures/electionfunction_example.tex}
				\caption{Exemple de jobs pour l'illustration du fonctionnement de la fonction d'élection}
				\label{fig:electionfunction_jobs}
			}
			\end{figure}

			\begin{figure}[!ht]
			\centering{
				\input{figures/electionfunction_timeline.tex}
				\caption{Illustration d'un appel à la fonction d'élection sur les \emph{jobs} $a$ et $b$}
				\label{fig:electionfunction_jobs}
			}
			\end{figure}

		\subsection{Place de l'ordonnancement dans Pip}

		Cet ordonnanceur ne s'exécute pas en espace privilégié, comme c'est le cas dans les systèmes d'exploitation traditionnels tels que Linux ou même dans des systèmes d'exploitation de niche tels que seL4. 

		La première raison en faveur d'une implémentation de l'ordonnanceur dans une partition de Pip concerne la méthode de conception des logiciels autour de Pip. En effet, placer l'ordonnanceur en espace utilisateur lui fait implicitement profiter des propriétés d'isolation des partitions de Pip. Ce choix est en adéquation avec la vision de Pip du système, conçu comme une tour de virtualisation. Une tour de virualisation dont chaque étage devient partie prenante de la base de confiance (TCB) des étages supérieurs. Dans le modèle de Pip, les différents logiciels se construisent les uns au dessus des autres, profitant des propriétés prouvées sur le logiciel sous-jacent.

		La seconde raison est une conséquence directe de ce choix, relatif à l'effort de preuve. Si l'ordonnanceur avait été implémenté dans Pip, alors il aurait fallu montrer que l'ordonnanceur respecte les propriétés d'isolation de Pip. \textcolor{red}{Inclure les métriques pour argumenter que cet effort serait non négligeable}. De plus, l'ordonnanceur développé dans cet contribution a été conçu autour de la politique d'ordonnancement EDF. Ce choix est arbitraire, et il serait tout à fait pertinent d'utiliser une autre politique d'ordonnancement pour Pip. Ainsi, il faudrait prouver les propriétés d'isolation de Pip pour chaque variante de l'ordonnanceur engendrée par chaque politique souhaitée.

		\subsection{Décomposition des éléments de l'ordonnanceur}
		\label{sec:project_overview}
			\subsubsection{Vue générale}
			\begin{figure}[!ht]
			    \centering
			    \input{figures/scheduler_overview.tex}
			    \caption{Overview of the scheduler components and their interactions}
			    \label{fig:project_overview}
			\end{figure}


			La figure \ref{fig:project_overview} donne une vue générale des composants de l'ordonnanceur et de leurs interactions. Le \emph{back-end} est le point d'entrée de l'ordonnanceur. Il est appelé par le noyau lorsqu'une interruption survient, appelle la fonction d'élection puis exécute le \emph{job} choisi par la fonction d'élection. Le \emph{back-end} doit aussi mettre à jour une partie de l'état sur laquelle repose la fonction d'élection, que nous appelons l'environnement. L'environnement est la partie de l'état disponible en lecture seule à la fonction d'élection, que la fonction d'élection peut interroger au travers des \emph{oracles}. La seconde partie est la partie mutable de l'état, que la fonction d'élection ne peut manipuler qu'au travers de l'\emph{interface}, principalement composée de types de données et de fonction pour les manipuler.

		\subsubsection{État interne de l'ordonnanceur}

			L'état interne de l'ordonnanceur est chargé de stocker les informations nécessaires à la fonction d'élection pour calculer le prochain \emph{job} à élire. Il existe deux représentations de cet état : une implémentation exécutable, et un modèle utilisé pour la preuve.

			L'état est -- de sucroit -- divisé en deux parties, qui se distinguent par leur fonction par rapport à la fonction d'élection. La première partie de l'état est maintenue par la fonction d'élection, qui peut y lire et y écrire des données à sa guise en utilisant l'interface de l'état prévue à cet effet. Cette partie de l'état est appelée l'état mutable. La seconde partie est la partie de l'état que la fonction d'élection ne peut qu'observer, qui est appelé l'environnement. L'environnement contient les informations relatives aux évènements extérieurs essentiels au bon fonctionnement de l'ordonnanceur, tels que l'arrivée de nouveaux \emph{jobs} à ordonnancer, ou la complétion d'un \emph{job} précédemment exécuté. Cette partie de l'état est donc accessible en lecture seule à la fonction d'élection. La fonction d'élection peut consulter l'environnement aux travers d'oracles, qui servent d'interface avec l'environnement.

		\subsubsection{Interface avec l'état -- Oracles, Types opaques et fonctions associées}
			
			Comme indiqué dans la sous-section précédente, la fonction d'élection effectue des modifications sur l'état ou observe l'environnement grâce à l'interface et aux oracles. Cette interface est \emph{nécessaire} car elle permet de définir les opérations qui doivent être supportées par l'état, et donc par ses deux représentations (le code exécutable et le modèle). Sans cette interface, certaines opérations pourraient être possible dans une des deux représentations sans qu'elle soit possible dans l'autre.
			L'interface ainsi que les oracles sont composés de types opaques, implémentés de manière indépendante dans les modèles ou dans le code exécutable. Ces types sont munis de fonctions elles aussi pourvues d'une implémentation exécutable ainsi que d'un modèle.

			Les oracles sont une partie de l'interface spécifique. Les oracles sont la partie de l'interface qui permet à la fonction d'élection d'observer les phénomènes extérieurs qui lui sont extérieurs, plus précisément la terminaison du \emph{job} précédemment exécuté et la liste des nouveaux \emph{jobs} à ordonnancer. Bien qu'ils disposent aussi de deux représentations, leur modèle ne décrit pas réellement les résultats que l'oracle doit produire, mais plutôt des contraintes sur les résultats produits. Le modèle va se contenter de décrire l'ensemble des résultats possibles, plutôt que d'en désigner un en particulier. Par exemple, une des contraintes sur la liste des nouveaux jobs est que leur date d'arrivée ne peut pas être supérieure à la date courante. 

		\subsubsection{Back-ends}
		\label{sec:back-ends}

		Nous avons vu que l'état est composé en partie d'une partie non mutable, appelée l'environnement. Les informations contenues dans l'environnement sont mises à jour par le \emph{back-end}. Le \emph{back-end} est aussi chargé d'appeler la fonction d'élection et d'exécuter le \emph{job} qui aura été élu.

		Cette contribution est munie de deux \emph{back-ends}.
		\begin{itemize}
			\item Le premier back-end est conçu comme une simulation permettant d'exécuter la fonction d'élection dans un simple processus Linux, afin de fournir des informations sur l'état interne de l'ordonnanceur. Ce back-end appelle la fonction d'élection, affiche le \emph{job} choisi pour exécution et autres informations d'intérêt sur l'état interne de la fonction d'élection tels que la liste des \emph{jobs} en attente, etc ;

			\item Le second back-end fourni est l'implémentation d'un ordonnanceur Earliest Dealine First dans une partition de Pip. Cette implémentation exécute la fonction d'élection et transfère le flôt d'exécution vers le \emph{job} élu par la fonction d'élection. Chaque job se trouve dans sa propre partition, avec un espace d'adressage qui lui est propre. Le flôt d'exécution revient au back-end soit lorsqu'une interruption d'horloge survient, interrompant le \emph{job} élu, soit lorsque le \emph{job} lui signale sa terminaison. Le back-end attend alors la prochaine interruption pour réélire un nouveau \emph{job}.
		\end{itemize}

		Les back-ends ne font pas partie du modèle mathématique de l'ordonnanceur, si ce n'est au travers des \emph{oracles}. Ils ne font pas partie de la politique d'ordonnancement ; ils appliquent simplement ses arbitrages et lui fournissent les informations dont elle a besoin.

		\subsubsection{Fonction d'élection}

		La fonction d'élection est divisée en deux parties principales. La première partie maintient la liste des \emph{jobs} en attente et sélection le prochain \emph{job} à exécuter, la seconde maintient la cohérence de son état interne.

		Dans la première partie, la fonction d'élection invoque un oracle, qui lui retourne la liste des nouveaux \emph{jobs} à ordonnancer. Ces jobs sont ajoutés à la liste des jobs à ordonnancer. Ensuite, elle invoque un autre oracle qui lui renvoie l'état du dernier job exécuté, afin de vérifier s'il a complété son exécution ou s'il a dépassé son échéance. S'il remplit l'une de ces deux conditions, il est enlevé de la liste des jobs à ordonnancer. Si il a excédé son échéance, l'erreur sera remontée lors du retour de la fonction. Enfin, la fonction récupère l'identifiant du premier \emph{job} de la liste (si la liste n'est pas vide) et le retourne avec le drapeau indiquant si le dernier \emph{job} exécuté a dépassé son échéance. Une valeur par défaut est retournée si aucun \emph{job} n'est disponible.

		La seconde partie de la fonction d'élection maintient la cohérence de l'état interne de la fonction d'élection pour les futurs appels. Elle commence par décrémenter le budget d'exécution du \emph{job} élu. Elle décrémente ensuite l'échéance relative des \emph{jobs} en attente, pour tenir compte du temps qui sera passé à exécuter le \emph{job} élu. Finalement, la fonction d'élection incrémente le compteur de temps, qui garde le compte de périodes de temps s'étant écoulées depuis le premier appel à la fonction d'élection.

	\section{Conduite de la preuve}

	\label{sec:proof}
	Cette section met en avant la preuve fonctionnelle de la fonction d'élection de l'ordonnanceur EDF, écrit sous la forme d'un programme monadique dans l'assistant de preuve Coq.

	Cette section commencera par décrire la méthodologie de preuve, qui utilise un raffinement en trois niveaux d'abstraction. La section décrira ensuite les différents niveaux d'abstraction et le raffinement qui les relie, en détaillant particulièrement pourquoi le raffinement préserve les propriétés de correction du niveaux d'abstraction supérieur. Enfin, la section conclura sur quelques détails d'élaboration de la preuve en Coq.

	\subsection{Méthodologie de preuve}

	Cette preuve est conduite par raffinement. Cette méthode permet d'appliquer la stratégie ``diviser pour régner'' pour gérer la complexité de la preuve.
	Cette preuve commence par une définition abstraite de la politique d'ordonnancement Earliest Deadline First, et montre que la politique est \emph{correcte}. Cette étape signifie que, sous réserve de quelques hypothèses, n'importe quel ensemble de \emph{jobs} ordonnançable ordonnancé selon cette politique sera ordonnancé tel que chaque \emph{job} complètera son exécution sans excéder son échéance.
	La preuve continue en définissant un algorithme de fonction d'élection idéalisé, et montre que cet algorithme implémente la politique d'ordonnancement définie précédemment. Il suit que l'algorithme idéalisé est aussi \emph{correct}.
	L'étape finale de la preuve consiste à écrire la fonction d'élection qui sera finalement compilée en code source C. Il faut ensuite montrer que la fonction d'élection qui sera traduite en C exhibe les mêmes comportements que l'algorithme idéalisé de la fonction d'élection (en particulier les effets de bord et les valeurs de retour). La preuve est alors complète, la preuve de correction a été propagée jusqu'au code C.
	%The properties proved in our work act as layered invariants that extend from the EDF policy model to the monadic code. To prove a new refinement layer, we start from the invariant of the previous (more abstract) layer and show that the new invariant \emph{refines} the previous one, i.e., the new invariant has a more detailed specification that remains compatible with its more abstract version.
	%All the proofs that we performed rely on the following assumptions.

	\subsubsection{Modèle de \emph{job}}
	\label{sec:jobmodel}
	Les \emph{jobs} sont modélisés comme des tuples $j = (i_j, r_j,d_j,c_j, \delta_j)$ d'entiers naturels, où $i_j$ est l'identifiant du \emph{job}, $r_j$ représente l'instant à partir duquel il est possible de l'ordonnancer (\emph{release date}), $d_j$ représente son échéance (\emph{deadline}), et $c_j$ représente son budget temporel, qui est une borne supérieure sur sa durée d'exécution. $\delta_j$ représente sa durée d'exécution maximum réelle (Worst Case Execution Time -- \emph{WCET}).

	Les \emph{jobs} doivent respecter certaines contraintes de construction :
	\begin{itemize}
		\item $r_i + c_i \leq d_i$, l'échéance est assez tardive pour que le \emph{job} puisse terminer son exécution sans la dépasser s'il est le seul à s'exécuter sur le processeur ;
		\item $0 < \delta_j \leq c_j$, le budget temporel alloué est bien une borne supérieure au temps d'exécution maximum réel (WCET), lui-même strictement positif ;
		\item l'identifiant de chaque \emph{job} doit être unique ;
		\item il n'existe qu'une seule occurrence de chaque \emph{job}.
	\end{itemize}

	\subsubsection{Hypothèse d'ordonnançabilité}

	Soient deux instants quelconques $t$ et $t'$ tels que $t < t'$, soit $\Gamma_{t, t'}$ l'ensemble des \emph{jobs} à ordonnancer dans l'intervalle $[t, t']$ (c'est à dire les \emph{jobs} $j$ ayant une release date $r_j$ supérieure à $t$ et une échéance $d_j$ inférieure à $t'$).
	L'hypothèse d'ordonnançabilité stipule que la somme des durées $\delta_j$ des \emph{jobs} à ordonnancer dans l'intervalle $[t, t']$ est inférieure à la durée $t'-t$ de l'intervalle.

	\begin{gather} \label{eq:schedulability}
    		\forall t, t'. ~t < t' \implies
    		\sum_{j \in \Gamma_{t, t'}}\delta_j \leq t' - t
	\end{gather}
%% \text{with:}
%% \begin{align*}
%%               \rho, \delta&\text{, arbitrary time instants},\\
%%               \Gamma_{\rho, \delta}&\text{, the set of jobs to schedule in the interval $[\rho, \delta]$},\\
%%               J_i&\text{, a job from }\Gamma_{\rho, \delta},\\
%%               r_i,~d_i,~C_i &\text{, respectively the release time, the deadline,}\\&\text{~~and the WCET of }J_i
%% \end{align*}
	Le fait qu'un ensemble de jobs ordonnançable puisse être ordonnancé par un ordonnanceur Earliest Deadline First sur un unique processeur est un résultat classique de la théorie de l'ordonnancement (\cite{stankovic2012deadline}, pp. 33-34). Les conditions d'ordonnançabilité d'un ensemble peuvent parfois être représentées plus simplement, par exemple lorsque les \emph{jobs} sont des instances de tâches périodiques. Cependant cette contribution porte sur un ordonnanceur de \emph{jobs arbitraires}, ce qui ne nous permet pas d'utiliser les hypothèses d'ordonnançabilité de cas spécifiques.

	\subsection{Couches d'abstraction et étapes de raffinement}

	\subsubsection{Politique d'ordonnancement Earliest Deadline First}
	\label{sec:policy}
	La première couche d'abstraction, la plus abstraite de toutes, est celle de la politique d'ordonnancement. Elle est définie de la manière suivante : pour tout \emph{job} $j$, et à n'importe quel instant $t$, si le \emph{job} $j$ s'exécute à l'instant $t$, alors pour chaque autre \emph{job} $j'$ qui aurait pu être exécuté à la place, on a $d_j \leq d_{j'}$.

	De manière formelle,
	\begin{equation*}
		\forall j, \forall t, [...]~\mathtt{run}~j~t~~\implies~~\forall j',~\mathtt{waiting}~j'~t~~\implies~~d_j \leq d_{j'}.
	\end{equation*}
\indent avec :
	\begin{align*}
		j, j'&\text{, deux identifiants de job},\\
		t&\text{, un instant arbitraire},\\
		\mathtt{run}~i~t&\text{, prouvable si le \emph{job} $j$ s'exécute à l'instant $t$},\\ 
		\text{waiting}~x~t&\text{, prouvable si le \emph{job} $j'$ est prêt à s'exécuter à l'instant $t$}
	\end{align*}

	La \emph{propriété de correction} pour la politique d'ordonnancement EDF est décrite de la manière suivante.
	Étant donné un ensemble ordonnançable de \emph{jobs} (c'est à dire satisfaisant l'hypothèse d'ordonnancement \ref{eq:schedulability}), si la politique d'ordonnancement EDF est appliquée, alors aucun \emph{job} de l'ensemble ne dépassera son échéance.
	
	\begin{gather*}
		\textit{ordonnançable} \implies\\
  		\forall j, \forall t.~~~\text{EdfPolicyUpTo}~t \implies\\
		\neg \text{overdue}~j~t.
	\end{gather*}
\indent	avec :
	\begin{align*}
		\text{EdfPolicyUpTo}~t&\text{ signifie que la politique a été appliquée jusqu'à l'instant}~t\\
		\text{overdue}~j~t&\text{, prouvable si le \emph{job} $j$ a dépassé son échéance à l'instant}~t
	\end{align*}

	\subsubsection{Fonction d'élection idéalisée implémentant la politique d'ordonnancement}
	\label{sec:functional}

	La première étape du raffinement est de montrer que la fonction d'élection idéalisée \texttt{functional\_scheduler\_star} implémente la politique d'ordonnancement EDF. La propriété suivante établie que si la fonction d'élection idéalisée est exécutée jusqu'à un certain instant $t$, alors la politique EDF a été appliquée jusqu'à cet instant.
	\begin{gather*}
		\forall t, \forall o, \forall s.~~~\texttt{functional\_scheduler\_star}~(t) = (o,s) \implies\\
		\text{EdfPolicyUpTo}~(\text{now}~s).
	\end{gather*}
\indent	avec :
	\begin{align*}
		s&\text{, l'état du programme après avoir exécuté la fonction}\\
		&~~\text{d'élection idéalisée après $t$ unités de temps},\\
		%\texttt{functional\_scheduler\_star}~(t)&\text{, appel à la fonction d'élection idéalisée pour $t$ unités de temps}\\
		\text{now}~s&\text{, extrait le compteur d'unité de temps de l'état $s$}\\
		o~&\text{, l'identifiant du \emph{job} élu à l'instant $t$}
	\end{align*}

	De cela, on peut déduire la propriété de correction de la fonction d'élection idéalisée :
	étant donné un ensemble de \emph{job} ordonnançable, alors pour tout \emph{job} $j$ de cet ensemble, ce \emph{job} ne dépassera pas son échéance à l'instant $t$ si la fonction a été appelée à chaque instant jusqu'à l'instant $t$

	\begin{gather*}
		\textit{ordonnançable} \implies\\
		\forall t, \forall o, \forall s.~~~\texttt{functional\_scheduler\_star}~(t) = (o,s) \implies\\
		\forall i.~~~\neg \text{overdue}~i~(\text{now}~s).
	\end{gather*}

	\subsubsection{Fonction d'élection monadique raffinant la fonction d'élection idéalisée}
	\label{sec:monadic}

	La prochaine étape consiste à prouver que la fonction d'élection monadique raffine la fonction d'élection idéalisée. Cette propriété contient des triplets de Hoare. 
	Les préconditions de la propriété sont paramétrés par un environnement observable \texttt{env} et par un état mutable $s$. Les postconditions sont paramétrées par la valeur de retour $o$ du programme $x$, et un état $s'$, le résultat de l'exécution du programme $c$ sur l'état $s$.

	Cette étape de raffinement peut être décrite de la manière suivante : pour tout instant $t$, si $(o, s')$ sont les valeurs retournées par la fonction d'élection monadique \texttt{scheduler\_star} sur l'environnement $E$ et l'état initial \texttt{init}, alors $(o, s')$ sont aussi les valeurs retournées par la fonction d'élection idéalisée \texttt{functional\_scheduler\_star} à l'instant $t$. Le triplet de Hoare correspondant est le suivant :
	\begin{gather*}
		\forall t.\\
		\{
		~\lambda~\mathtt{env}~s.~~~\mathtt{env} = E~~\land~~s = \mathtt{init}~
		\}\\
		\texttt{scheduler\_star}~(t)\\
		\{
		~\lambda~o~s'.~~~\texttt{functional\_scheduler\_star}~(t) = (o,s')~
		\}
	\end{gather*}

	À partir de ce triplet, on peut déduire le triplet de Hoare exprimant la propriété de correction de la fonction d'élection monadique.

	\begin{gather*}
		\textit{ordonnançable} \implies\\
		\forall t.\\
		\{
		~\lambda~\mathtt{env}~s.~~~\mathtt{env} = E~~\land~~s = \mathtt{init}~
		\}\\
		\texttt{scheduler\_star}~(t)\\
		\{
		~\lambda~\_~s'.~~~\forall i.~~~\neg \text{overdue}~i~(\text{now}~s') ~
		\}
	\end{gather*}


	\subsection{Hypothèses et déroulement de la preuve en Coq}

	Les détails de la preuve sont disponibles sur le dépot, et nous avons décrit la structure principale de la preuve. Nous allons ici développer les faits les plus caractéristiques de cette preuve, donnant une vision plus précise de son déroulement. 

	Les preuves Coq suivent de près l'approche par raffinement décrite dans la sous-section précédente. Tout d'abord, le modèle choisi pour les jobs, décrit sous forme mathématiquement dans la section \ref{sec:jobmodel} est implémenté dans l'assistant de preuve. Les hypothèses listées dans la même section \ref{sec:jobmodel} sont des hypothèses globales, qui s'appliquent donc à l'ensemble de la preuve. Il est facile d'argumenter que ces hypothèses sont des hypothèses raisonnables sur l'ensemble étudié, c'est à dire qui ne restreignent pas les ensembles considérés, ou sans lesquelles l'ordonnancement d'un tel ensemble est impossible.

	La première couche d'abstraction modélisant la politique d'ordonnancement nécessite des hypothèses supplémentaires. Ces hypothèses -- appelées hypothèses \emph{locales} -- ne sont utilisées que pour établir la preuve de correction de la politique. Elles disparaissent dès le premier raffinement vers la fonction d'élection idéalisée ; ces hypothèses deviennent alors des définitions et des lemmes Coq.

	On suppose localement que deux fonctions sont fournies avec la politique : \texttt{run} qui permet de déterminer quel \emph{job} sera exécuté à n'importe quel instant, et \texttt{rem}, qui garde le compte du temps d'exécution restant de chaque \emph{job} à n'importe quel moment.
	Ces fonctions ont besoin elles aussi d'hypothèses locales supplémentaires, qui représentent des propriétés générales sur l'ordonnancement mono-processeur :
	
	\begin{itemize}
		\item à chaque instant, au maximum un \emph{job} est exécuté;
		\item le temps d'exécution restant d'un \emph{job} est égal à sa durée au moins jusqu'à sa \emph{release date};
		\item le temps d'exécution restant d'un \emph{job} diminue lorsqu'il est exécuté, et reste constant lorsqu'il ne l'est pas;
		\item il y a un \emph{job} qui s'exécute à chaque instant où au moins un \emph{job} est prêt à être exécuté.
	\end{itemize}

	\label{sec:proof_insight}

	Le premier raffinement représente la plus grosse portion de la preuve. Ce raffinement consiste à définir les fonctions abstraites \texttt{run} et \texttt{rem} supposées fournies dans la couche d'abstraction de la politique, puis à prouver les hypothèses localement supposées sur ces fonctions.
		Une fois ces hypothèses prouvées, la propriété de correction de la fonction d'élection idéalisée est une simple conjonction entre la propriété de correction de la politique d'ordonnancement et la propriété de raffinement. Il est plus intéressant de prouver une relation d'implémentation plutôt que de prouver directement la propriété de correction de la fonction d'élection idéalisée, car les obligations de preuve de la preuve par raffinement sont plus concrètes. La preuve par raffinement nécessitant l'établissement d'abstractions avant son écriture, elle nous propose des termes de preuves plus directs que ceux qui auraient été proposés par la preuve directe.

	Toutes les propriétés à prouver à ce niveau de raffinement sont des \emph{invariants} -- des prédicats qui doivent être vrais sur tous les états atteignables depuis l'état initial, obtenus en exécutant un nombre arbitraire de fois la fonction d'élection idéalisée. La preuve de certains de ces invariants a cependant nécessité la conception d'invariants \emph{inductifs} supplémentaires, vrais sur l'état initial, et préservés par chaque exécution subséquente de la fonction d'élection idéalisée. Ces invariants ont été conçus de telle manière à ce qu'ensembles, ils impliquent l'invariant initial à prouver.

	La dernière étape de raffinement permet de montrer que la fonction d'élection exécutable raffine la fonction d'élection idéalisée. Elle consiste à montrer que l'ensemble des états atteignables par la fonction d'élection exécutable est inclus dans l'ensemble des états atteignables par la fonction d'élection idéalisée. 
	La différence notable entre les deux fonctions d'élection est que la fonction d'élection idéalisée calcule en une grosse itération ce que la fonction d'élection exécutable calcule en plusieurs petites itérations. La fonction d'élection idéalisée n'est pas assujettie à de telles contraintes et peut de ce fait factoriser ces longues séquences de petites itérations en une seule grosse itération. Ce faisant, la fonction d'élection idéalisée nous avait épargné la preuve d'invariants supplémentaires à propos des états intermédiaires générés par la fonction d'élection exécutable, qu'il a fallu prouver dans cette étape de raffinement.

	La conclusion globale indiquant la fonction d'élection exécutable est correcte découle de la propriété de correction de la politique d'ordonnancement et des preuves des deux raffinements successifs.

	\textcolor{red}{Il faut une transition c'est trop raide}

	\section{Implémentation et modèle de l'état et de son interface}

	Cette section commencera par rappeler le rôle de la monade d'état dans le monde mathématique et de la nécessité de son interface. Elle illustrera ensuite le problème de \emph{dualité} des modèles et de l'objet réel modélisé avec un exemple s'étant présenté pendant l'implémentation.
	Dans une seconde partie, cette section présentera notre implémentation et les modèles relatifs à l'état et aux fonctions de l'interface.
	Cette section décrira l'implémentation de l'interface avec la monade d'état, qui permet à la fonction d'élection d'intéragir avec l'état interne du programme.
		\subsection{Dualité implémentation/modélisation}
		\label{sec:model_distortion}
			La monade d'état représente l'état du programme dans le monde fonctionnel du modèle qui en est autrement dépourvu. Les fonctions qui permettent d'interagir avec la monade d'état constituent son interface. Lors de la compilation du code Gallina vers du code C, la monade d'état disparaît, pour laisser place à l'état intrinsèque du monde impératif.
			Il existe donc deux penchants de l'interface : le modèle, intéragissant avec la monade d'état, et son implémentation, intéragissant directement avec l'état intrinsèque du programme. Cette interface est supposée correcte : on suppose que l'appel à une fonction de l'interface a les mêmes effets dans le monde mathématique et dans le monde réel. La méthode usuelle pour minimiser l'impact de cette supposition est de créer une interface constituée de fonctions dont les effets sur l'état sont les plus simples possibles, idéalement de l'ordre d'une simple instruction assembleur.
			Malheureusement, cette méthode est souvent en tension avec l'effort de preuve, qui augmente de manière exponentielle lorsque les modèles se rapprochent de plus en plus du matériel. Ainsi, chaque modèle trouve son propre point d'équilibre entre coût de la preuve et risque de distorsion entre le modèle et la réalité.

			Pour illustrer ce propos, voici un exemple relatif à l'établissement de la preuve décrite dans la section précédente. Afin de simplifier grandement la preuve, notre monade d'état contient des listes. Le modèle de l'interface repose de ce fait sur les listes fonctionnelles du langage, qui créent des copies à chaque opération et qui ne manquent jamais de mémoire. Ce type de liste \emph{idéalisé} ne peut être implémenté qu'avec des logiciels ad-hoc lourds comme, par exemple, les ramasse-miettes. Incorporer de tels logiciels dans la base de confiance est en nette contradiction avec notre méthodologie.
			Nous avons de ce fait décidé d'opter pour une interface utilisant des listes avec modification en place, de telle sorte à fournir une interface qui soit pratique à utiliser dans le code monadique, dont le modèle fonctionnel est simple du point de vue de la preuve, et qui soit facile à implémenter en C. Ce choix nous contraints néanmoins à ne jamais laisser l'utilisateur manipuler les objets de listes directement, sous peine de créer une distorsion entre la réalité et le modèle.

Pour illustrer cette distorsion, prenons par exemple la séquence d'instructions idéalisée suivante :
\begin{verbatim}
do liste_initiale <- get_liste_initiale;
do liste_modifiee <- modifie_liste liste_initiale;
do queue_liste_initiale <- get_tail liste_initiale;
\end{verbatim}

Dans le monde fonctionnel, l'interface utilise les listes \emph{idéalisées} qui retournent des \emph{copies} (éventuellement modifiées) de la liste initiale. La variable \texttt{queue\_liste\_initiale} contient effectivement une référence vers une copie de la queue de la liste initiale. Cependant, l'implémentation réelle de l'interface utilise une implémentation de liste sans copie, avec une modification des listes en place. La variable \texttt{queue\_liste\_initiale} contient une référence vers la queue de la seule liste existante, c'est à dire celle de la liste modifiée.

Afin d'éviter de s'exposer à ce problème de distortion, notre interface ne fournit donc pas d'objet de liste, mais des fonctions pour modifier les listes contenues dans l'état. Cette approche a cependant le désavantage de créer des primitives non-triviales, comme par exemple l'insertion triée dans une liste. Nous reviendrons sur ce choix d'inclusion de fonctions non-triviales dans l'interface (et donc dans la base de confiance) à la fin de ce chapitre, dans la section \ref{sec:interfaceTCB}. 
		
		\subsection{Implémentation vue comme un cas particulier de l'interface abstraite}
	\label{sec:monad}

	Cette sous-section détaille comment l'interface du code vérifié avec l'état a été conçue, décrivant à la fois les modèles et leur implémentation.
	Pour rappel, les différentes parties de l'interface et leurs interactions sont représentées dans la section \ref{sec:project_overview}, dans la figure \ref{fig:project_overview}.

	Cette section décrira d'abord l'état interne de la fonction d'élection, composé de deux parties : une partie en lecture seule appelée l'environnement, et une partie mutable. Ensuite, la section expose comment la fonction d'élection utilise les \emph{oracles} pour récupèrer les informations de l'environnement, et comment la fonction d'élection utilise l'interface pour manipuler la partie mutable de l'état.

	\subsubsection{État de l'ordonnanceur}

	Le modèle de l'état est divisé en deux parties : l'environnement, contenant les valeurs calculées par le back-end sur lesquelles la fonction d'élection n'a aucun contrôle, et la partie de l'état modifiable par la fonction d'élection.

	Le modèle de l'environnement \texttt{Env} est défini comme une fonction qui, en fonction de l'instant passé en paramètre, retourne la liste des \emph{jobs} à ajouter à la liste des \emph{jobs} prêts à être ordonnancés.
	\begin{minted}{coq}
Record Job  :=
mk_Job {
    jobid : CNat ;
    arrival : CNat ;
    duration : CNat ;
    budget : CNat ;
    deadline : CNat
}.

Definition Env : Type := CNat -> list Job.
	\end{minted}

	Le modèle de la partie mutable \texttt{State} est constitué d'une structure avec deux champs. Le premier est un simple compteur de temps, gardant le compte des interruptions d'horloge ; l'autre champ est une liste d'\texttt{entries}. Les \emph{entries} sont des structures qui associent chaque \emph{job} à son budget d'exécution restant et à son échéance relative. Le modèle de cet état mutable est donc défini de la manière suivante :
\begin{figure}[ht]
\begin{minipage}[c]{0.50\linewidth}
\begin{minted}{coq}
Record Entry :=
mk_Entry {
    id : CNat ;
    cnt : CNat ;
    del : CNat
}.
\end{minted}
\end{minipage}
\begin{minipage}[c]{0.50\linewidth}
\begin{minted}{coq}
Record State :=                     
mk_State {                      
    now : CNat ;                 
    active : list Entry ;
}.

\end{minted}
\end{minipage}

\end{figure}

	La monade d'état, composé de l'environnement et de la partie mutable, a le type suivant :
	\begin{minted}{coq}
Definition RT (A : Type) : Type :=
    Env -> State -> A * State.
	\end{minted}
	Dans notre modèle, chaque fonction monadique a un type de retour \texttt{RT A}, et prend donc en paramètre l'environnement et l'état mutable actuel et renvoie une valeur de type arbitraire \texttt{A} ``enrobée'' avec la nouvelle partie mutable de l'état.

	Les paragraphes suivants décrivent comment l'état est implémenté.
	L'implémentation profite du fait que la fonction d'élection crée une nouvelle structure \texttt{entry} pour chaque \emph{job} à ordonnancer. L'implémentation réserve de l'espace mémoire supplémentaire dans la structure de chaque \emph{job}, afin que la fonction d'élection puisse y écrire la structure \texttt{entry} associée.

	Notre implémentation fournit un ensemble jouet de job à ordonnancer sous la forme d'un tableau de \texttt{coq\_N} éléments (où \texttt{coq\_N} est une borne supérieure au nombre de \emph{jobs} à ordonnancer connue à la compilation). Les jobs sont discriminés par leur position au sein de ce tableau. Chaque élément de ce tableau correspond donc à un \emph{job} de l'ensemble à ordonnancer. Il contient les informations immuables qui le caractérisent (par exemple sa \emph{release date}, son échéance, son budget temporel d'exécution), ainsi qu'une portion de mémoire non initialisée qui sera utilisée par la fonction d'élection pour y écrire la structure \texttt{entry} qui lui est associée. De plus, chaque élément contient deux mots mémoire supplémentaires. Ils sont utilisés pour maintenir deux listes nécessaires au fonctionnement de l'ordonnanceur. La première est la liste des nouveaux \emph{jobs} à ordonnancer, exposée par l'environnement et maintenue par le \emph{back-end}. La seconde est la liste des \emph{jobs} prêt à être exécutés, maintenue par la fonction d'élection.

	Chaque élément est représenté en C avec le type suivant :
	\begin{listing}[!hb]
	\begin{minted}{c}
typedef struct __internal_s__ {
    struct __internal_job__   job;
    struct __internal_entry__ entry;
    int jobset_next_job_index;
    int active_next_entry_index;
} internal_t;
	\end{minted}
	\caption{Implémentation du type des éléments du tableau contenant les \emph{jobs} à ordonnancer}
	\label{code:array_elem_impl}
	\end{listing}

	L'implémentation de l'état, donnée en listing \ref{code:sched_state_impl}, est donc constituée :
	\begin{itemize}
		\item du tableau contenant les informations sur les \emph{jobs} et l'espace supplémentaire requis par la fonction d'élection pour y stocker les structures \texttt{entry}
		\item d'une référence vers la liste des nouveaux \emph{jobs} à ordonnancer
		\item d'une référence vers la liste des \emph{jobs} prêts à être ordonnancés
		\item de la variable gardant le compte des interruptions d'horloge
		\item de la variable indiquant si le dernier \emph{job} exécuté a terminé son exécution
	\end{itemize}

	\begin{listing}[!ht]
	\begin{minted}{c}
internal_t INTERNAL_ARRAY[coq_N] = EXAMPLE_JOB_SET;
int JOBS_ARRIVING_HEAD_INDEX = -1;
int ACTIVE_ENTRIES_HEAD_INDEX = -1;
unsigned int CLOCK = 0;
coq_CBool JOB_DONE = false;
	\end{minted}
	\caption{Implémentation de l'environnement et de la partie mutable de l'état de l'ordonnanceur}
	\label{code:sched_state_impl}
	\end{listing}

	\subsubsection{Oracles}

	Il existe deux fonctions qui retournent des valeurs de l'environnement calculées par le back-end. La première, \texttt{jobs\_arriving}, récupère les nouveaux \emph{jobs} à ordonnancer ; la seconde, \texttt{job\_terminating}, retourne si le dernier \emph{job} exécuté a terminé son exécution (si un tel \emph{job} existe). Nous appelons ces fonctions les \emph{oracles} de l'ordonnanceur, car leur modèle ne décrit que les contraintes imposées sur les résultats qu'elles produisent, et non pas comment ces résultats sont fournis.

	La fonction \texttt{jobs\_arriving}, qui récupére les identifiants des nouveaux jobs à ordonnancer, a un modèle n'imposant qu'une seule contrainte à l'implémentation : dans la liste des identifiants de \emph{jobs} retournés par l'oracle, aucun identifiant ne doit être plus grand que $N$, où $N$ est une borne supérieure définie à la compilation. Cette borne est la même que la borne \texttt{coq\_N} présentée dans la section précédente sur l'implémentation de l'état. La liste renvoyée par l'oracle est cachée derrière le type opaque \texttt{JobSet}.\\
	Le modèle de cette fonction est exposé dans le listing \ref{code:jobs_arriving_model}.

	\begin{listing}[!ht]
	\begin{minted}{coq}
Definition jobs_arriving (N : nat) : RT JobSet :=
  fun env s =>
    let f :=  List.filter
      (fun j =>  Nat.ltb j N)
      (map jobid (env s.(now))) 
  in (f, s).
	\end{minted}
	\caption{Modèle de l'oracle \texttt{jobs\_arriving}}
	\label{code:jobs_arriving_model}
	\end{listing}

	Rappelons que ce modèle n'indique aucunement comment calculer une telle liste de \emph{jobs}. Ce choix est délibéré, afin de s'assurer que la fonction d'élection n'est pas en capacité de prévoir l'arrivée de nouveaux \emph{jobs}, guarantissant que n'importe quel ensemble arbitraire de \emph{jobs} puisse être utilisé avec cet ordonnanceur.

	L'implémentation de la fonction retournant la prédiction de l'oracle est particulièrement simple : elle retourne simplement la variable de l'état contenant la référence vers la liste des nouveaux \emph{jobs} à ordonnancer. Plus précisement, cette variable contient l'indice de l'élément du tableau étant en tête de cette liste. La liste a été construite par le back-end avant l'exécution de la fonction d'élection qui fait appel à l'oracle. La construction de cette liste est donc totalement déléguée à l'implémentation du back-end, sans aucune répercussion sur le monde mathématique.

	\begin{listing}[!ht]
	\begin{minted}{c}
static inline coq_JobSet
Primitives_jobs_arriving(coq_CNat n) {
     return JOBS_ARRIVING_HEAD_INDEX;
}
	\end{minted}
	\caption{Implémentation de l'oracle \texttt{jobs\_arriving}}
	\label{code:jobs_arriving_impl}
	\end{listing}

	L'autre oracle est une fonction qui retourne si le \emph{job} exécuté durant la précédente période d'exécution a terminé son exécution (si un tel \emph{job} existe). Le modèle de cet oracle est plus strict ; il force l'implémentation de l'oracle à retourner \texttt{True} si le nombre de périodes passées à exécuter le \emph{job} excède son \emph{WCET}. Son modèle est présenté en figure \ref{code:jobs_terminating_model}.

	\begin{listing}[!ht]
	\begin{minted}{coq}
Definition job_terminating : RT CBool :=
fun _ s => ((
    match head s.(active) with
    | None => false
    | Some e =>
        let j := Jobs (e.(id)) in
        Nat.leb e.(cnt) (j.(budget) - j.(duration))
    end
), s).
	\end{minted}
	\caption{Modèle de l'oracle \texttt{job\_terminating}}
	\label{code:jobs_terminating_model}
	\end{listing}

	Ce modèle décrémente le compteur \texttt{e.(cnt)} à partir d'une valeur initiale de \texttt{j.(budget)} à chaque fois que le \emph{job} est élu pour exécution. Tout comme l'implémentation de l'oracle précédent, l'implémentation de cet oracle est particulièrement simple, comme démontré en listing \ref{code:job_terminating_impl}. Elle ne fait que retourner la variable \texttt{JOB\_DONE} de l'état interne; cette variable est mise à jour par le \emph{back-end} lorsqu'un \emph{job} termine son exécution, et remis à \texttt{False} après chaque appel à la fonction d'élection.

	\begin{listing}[!ht]
	\begin{minted}{c}
static inline coq_CBool Primitives_job_terminating(void) {
    return JOB_DONE;
}
	\end{minted}
	\caption{Implémentation de l'oracle \texttt{job\_terminating}}
	\label{code:job_terminating_impl}
	\end{listing}

	La dernière portion de cette section détaillera l'interface de la fonction d'élection avec la partie mutable de l'état.

	\subsubsection{Types opaque et interface avec l'état mutable}

	Tous les types utilisés par la fonction d'élection sont des types opaques, c'est à dire que des types agnostiques de leur représentation et uniquement définis au travers des fonctions qui permettent de les manipuler, qu'on appelle leurs \emph{primitives}.

	Ces travaux comportent des types opaques pour des valeurs booléennes, pour des entiers, pour les structures en lecture seule telles que celles contenant les informations initiales sur les \emph{jobs} ou la liste des nouveaux \emph{jobs} à ordonnancer, ainsi que pour les structures contenant des données mutables telles que les structures \texttt{entry}. La plupart des primitives sur ces types sont extrêmement simples ; par exemple, le type \texttt{CBool} permettant de représenter les booléens est muni de trois primitives : \texttt{not}, \texttt{and}, et \texttt{or}. Le listing \ref{code:boolean_definition_prim} montre la modélisation de ce type avec sa primitive \texttt{or}. Son implémentation est décrite dans le listing \ref{code:boolean_definition_impl}.

	\begin{listing}[!ht]
	\begin{minted}{coq}
Definition CBool := bool.

Definition or (b1 b2 : CBool) : RT CBool :=
  ret (orb b1 b2).
	\end{minted}
	\caption{Modèle du type opaque \texttt{CBool} et de sa primitive \texttt{or}}
	\label{code:boolean_definition_prim}
	\end{listing}

	\begin{listing}[!ht]
	\begin{minted}{c}
typedef int coq_CBool;

static inline coq_CBool CBool_or(coq_CBool b1, coq_CBool b2) {
    return b1 || b2;
};
	\end{minted}
	\caption{Implémentation du type opaque \texttt{CBool} et de sa primitive \texttt{or}}
	\label{code:boolean_definition_impl}
	\end{listing}

	Les structures mutables, telles que le type \texttt{entry}, sont munies de primitives permettant de les créer, ainsi que de lire et modifier leurs champs. Dans le même esprit, les structures de données en lecture seule ne sont munies que de primitives permettant de lire les informations qu'elles renferment. Par exemple, le type opaque \texttt{JobSet}, retourné par l'oracle \texttt{jobs\_arriving} n'est muni que de trois primitives : une vérifiant si l'ensemble est vide, une autre récupérant le premier élément de l'ensemble, et une dernière retournant un plus petit \texttt{JobSet} contenant les \emph{jobs} restants. Le type opaque \texttt{Job} quand à lui ne possède que des primitives permettant de récupérer individuellement chaque champ de la structure.
	
	Enfin, il existe huit autres primitives conçues pour intéragir directement avec l'état mutable de la fonction d'élection. La fonction d'élection a notamment besoin de gérer le compteur d'interruption d'horloge ; pour cela il existe deux primitives, un \emph{getter} et un \emph{setter} pour la variable de compteur.
	Ces fonctions sont extrêmement simples à modéliser et implémenter, comme en attestent les listings \ref{code:time_counter_model} et \ref{code:time_counter_impl}.

	\begin{listing}[!ht]
	\begin{minted}{coq}
Definition get_time_counter : RT CNat :=
fun _ s => ((now s), s).

Definition set_time_counter (counter : nat) : RT unit :=
fun _ s => (tt,
    {|
        now    := counter ;
        active := (active s) ;
    |}).
	\end{minted}
	\caption{Modèle des fonctions de récupération et de modification de la variable de compteur de l'état}
	\label{code:time_counter_model}
	\end{listing}

	\begin{listing}[!ht]
	\begin{minted}{c}
static inline coq_CNat State_get_time_counter(){
    return CLOCK;
};

static inline void State_set_time_counter(coq_CNat counter){
    CLOCK = counter;
};
	\end{minted}
	\caption{Implémentation des fonctions de récupération et de modification de la variable de compteur de l'état}
	\label{code:time_counter_impl}
	\end{listing}

	La fonction d'élection doit aussi maintenir la liste des jobs prêts à être ordonnancés. Elle a à sa disposition six primitives :
	\begin{itemize}
		\item une primitive permettant de vérifier si cette liste est vide
		\item une primitive retournant le \emph{job} à la tête de la liste
		\item une primitive ajoutant un \emph{job} à la liste de manière triée selon une fonction de comparaison fournie en paramètre
		\item une primitive retirant le premier job de la liste
		\item une primitive mettant à jour la structure \texttt{entry} liée au premier \emph{job} de la liste
		\item une primitive mettant à jour la structure \texttt{entry} de tous les \emph{job} de la liste
	\end{itemize}

	\begin{listing}[!ht]
	    \centering
	%    \begin{verbatim}
	    \begin{minted}{coq}
Definition insert_new_active_entry (entry : Entry)
           (comp_func : Entry -> Entry -> CBool) : RT unit :=
  fun _ s => (tt, {|
    now := now s ;
    active := (insert_Entry_aux entry (active s) comp_func);
  |}
).

Fixpoint insert_Entry_aux (entry : Entry) (entry_list : list Entry)
         (comp_func : Entry -> Entry -> CBool) : list Entry :=
  match entry_list with
  | nil => cons entry nil
  | cons head tail =>
      match comp_func entry head with
      | true => cons entry (cons head tail)
      | false => cons head (insert_Entry_aux entry tail comp_func)
      end
  end.


	    \end{minted}
	    \hrule
	    \begin{minted}{c}


void State_insert_new_active_entry
     (coq_Entry entry, entry_cmp_func_type entry_comp_func) {
  int *entry_index_ptr = &(ACTIVE_ENTRIES_HEAD_INDEX);
  int next_index = -1;
  while (*entry_index_ptr != -1) {
    if (entry_comp_func(entry, &(INTERNAL_ARRAY[*entry_index_ptr].entry))) {
      next_index = *entry_index_ptr;
      break;
    }
    entry_index_ptr = &(INTERNAL_ARRAY[*entry_index_ptr].active_next_entry_index);
  }
  *entry_index_ptr = entry->id;
  INTERNAL_ARRAY[entry->id].active_next_entry_index = next_index;
}
	    \end{minted}
	    \caption{Comparaison entre le modèle de la primitive d'insertion triée dans la liste et son implémentation}
	    \label{code:model_impl_cmp}
	\end{listing}

		La plupart de ces primitives sont aussi simples à modéliser qu'à implémenter ; cependant deux d'entre elles dérogent à cette règle. La première est la fonction \texttt{insert\_new\_active\_entry}, qui insère une structure \texttt{entry} (contenant les valeurs manipulables d'un job par la fonction d'élection) de manière triée selon une fonction de comparaison. Son modèle est donné dans la moitié supérieure du listing \ref{code:model_impl_cmp}.

		Étant donné une structure \texttt{entry} et une fonction de comparaison, ce modèle extrait d'abord la liste du modèle de l'état de l'ordonnanceur. Le modèle passe cette liste à une fonction auxiliaire purement fonctionnelle qui retourne la liste contenant la structure \texttt{entry} à insérer. Cette fonction auxiliaire crée en réalité une nouvelle liste, en comparant chaque structure \texttt{entry} de la liste initiale avec la structure \texttt{entry} à insérer grâce à la fonction de comparaison passée en paramètre, et en ajoutant au fur et à mesure des copies des éléments à cette liste.

		Pour des raisons de performances et de minimisation de la base de confiance, l'implémentation ne crée pas de nouvelle liste à chaque nouvelle insertion, mais modifie en place la liste actuelle. L'interface choisie empêche le problème de distortion exposé dans la section précédente \ref{sec:model_distortion}, où le modèle crée des copies et où l'implémentation modifie la liste en place.

		Le code de l'implémentation, disponible dans la motié inférieure du listing \ref{code:model_impl_cmp}, est similaire à la fonction auxiliaire récursive du modèle, mais utilise une boucle et met à jour le lien entre les éléments quand la nouvelle struture \texttt{entry} est insérée, plutôt que de créer des copies des éléments de la liste en les réordonnant correctement. 

		La fonction \texttt{update\_active\_entries}, qui applique une modification arbitraire à chaque structure \texttt{entry} de la liste, a subit la même méthode de modélisation et d'implémentation. L'implémentation modifie les éléments de la liste en place plutôt que de créer une nouvelle liste avec des copies modifiés des éléments originaux.

	\label{sec:implementation}

		Nous défendons l'argument que les primitives présentées dans cette section, définissant l'interface de la fonction d'élection avec l'implémentation réelle de l'ordonnanceur et de son état interne, sont assez simples pour se convaincre que les effets de leur implémentation correspond bien au effet décrits par leur modèle. Néanmoins, les fonctions \texttt{insert\_new\_active\_entry} et \texttt{update\_active\_entries} présentées à la fin de cette section sont objectivement plus complexes que les autres primitives présentées. Cet argument est débatable sur ces deux fonctions ; aussi la section \ref{sec:interfaceTCB} présentera des arguments supplémentaires en faveur de ce choix de primitives.

	\section{Discussion sur la méthodologie suivie}

		Cette section sert de retour d'expérience sur la contribution, en prenant du recul sur le travail fourni.
		Elle commence par présenter différentes métriques concernant l'ordonnanceur, discutant des proportions de code prouvé, de lignes de preuves et de lignes d'implémentation, et du temps investi. Dans une seconde partie, cette section discutera des choix fait pour ces travaux, et plus particulièrement du choix des primitives et de l'impact de ce choix sur la confiance apportée par la preuve.

		\subsection{Métriques}

		La partie technique de cette contribution est le fruit de 9 mois de travail de deux personnes à temps plein, aidés ponctuellement par d'autres membres de nos équipes de recherche respectives. La présentation de l'ordonnanceur en conférence et la publication du papier ont eu lieu un an et demi après le premier commit sur le dépôt de code du projet.

			\subsubsection{Implémentation}
			La fonction d'élection, écrite en Gallina, compte à elle seule environ 150 lignes de code. L'implémentation de l'état, des types opaques et des fonctions formant l'interface avec l'état compte environ 350 lignes de code C, composé majoritairement de fichiers \emph{headers} particulièrement verbeux.

			Concernant le back-end de \emph{simulation} de l'ordonnanceur, celui-ci a requis environ 100 lignes de code C. L'implémentation de la partition de Pip contenant l'ordonnanceur préemptif temps réel, sans compter la fonction d'élection ni l'implémentation de l'état et de l'interface, compte pour environ 1150 lignes de code. Sont pris en compte, les fichiers de code C et leur \emph{headers}, les fichiers de code assembleur, mais aussi les scripts d'édition de liens. En revanche, ce nombre de lignes ne contient pas les lignes de la librairie utilisateur de Pip. Sur ces 1150 lignes, environ 900 lignes sont requises par Pip pour créer les partitions de l'ordonnanceur et des \emph{jobs}, ainsi que pour mapper leur code dans leur espace d'adressage respectifs. Les 250 lignes restantes sont dédiées au fonctionnement de l'ordonnanceur en lui-même.

			\subsubsection{Modèles et preuves}
			
			Les modèles de l'état, des types opaques, et des fonctions permettant d'intéragir avec l'état représentent en tout environ 650 lignes de code.

			Pour rappel, la preuve se découpe en trois parties majeures : la définition de la politique d'ordonnancement \emph{Earliest Deadline First} et l'établissement de sa propriété de correction , l'implémentation d'une fonction d'élection idéalisée et de sa preuve de raffinement de la politique d'ordonnancement, puis d'un raffinement vers la fonction d'élection qui sera traduite en C.

			La première partie de cette preuve concernant la correction de la politique d'ordonnancement est relativement courte. L'écriture de la politique d'ordonnancement, avec sa preuve de correction représente environ 1100 lignes de code et de preuve. Ce nombre de lignes relativement restreint est dû au haut niveau d'abstraction, profitant à l'établissement de la preuve : cela permet de se concentrer sur l'essentiel sans s'encombrer de détails d'implémentation.
		
			Comme énoncé dans la section \ref{sec:proof_insight}, le premier raffinement, allant de la politique d'ordonnancement vers la fonction d'élection idéalisée, représente la majeure partie de la preuve, et qui a necéssité de redoubler d'ingéniosité. Cela s'explique par le fossé d'abstraction entre la politique d'ordonnancement (composée de termes algébriques relativement simples), et la couche d'abstraction de la fonction d'élection idéalisée qui décrit la politique en fonction d'opération sur des structures de données, en particulier des listes chainées. Cette partie de la preuve représente environ 1600 lignes de Coq (comptabilisant aussi les lignes de code de la fonction d'élection idéalisée).

			Le second raffinement est relativement simple comparé au premier raffinement, car les fonctions d'élection idéalisées et exécutables sont à des niveaux d'abstractions relativement proches ; en particulier, elles utilisent les mêmes structures de données. À titre de comparaison, cette dernière étape de raffinement est courte, environ 500 lignes de preuve.

			Ainsi, l'établissement de la preuve sur la fonction d'élection longue de 150 lignes a nécessité au total 3250 lignes de Coq, quand le nombre total de ligne nécessaires pour implémenter l'ordonnanceur avoisinne les 1400 lignes de code. Le code prouvé représente donc environ 10\% du code total de l'ordonnanceur.


		\subsection{Choix des primitives et discussion sur la base de confiance}
		\label{sec:interfaceTCB}
		Formal proofs transfer confidence from hypotheses (or premises) to conclusions. In computer security hypotheses are called the trusted computing base. We have divided the implicit and explicit hypotheses of the trusted computing base into three categories. The first category of assumptions, the most fundamental ones, are assumptions about the correctness of the hardware and tools used to check the proof itself. The second category of assumptions includes properties expected of software libraries and runtime environments. And the last category of assumptions arises from the compilation process, more precisely from the semantics of the operations used by the source code (on which the proof is based) and the semantics of the operations used by the target code (which is actually executed). In this section, we question the trusted computing base of our work and discuss it in light of related works.

\subsubsection{Fundamental barriers}

In this subsection we focus on the trusted computing base that is, to the best of our knowledge, common to the whole formal code verification community.

The first common TCB is the tool used to achieve the formal verification. In our case, this is the Coq proof assistant. It is based on a logic called the calculus of inductive constructions. It assists the user in incrementally building a proof in this logic. Its critical part is its kernel -- the piece of code that checks whether a tentative proof is an actual proof. One can reasonably trust the kernel of Coq and include it in the TCB.

The second, orders of magnitude larger, common TCB is the specification of the hardware running the verified code. There are two parts to this argument, that are closely related to the two steps of algorithm implementation exposed in Section \ref{sec:motivations}.

\begin{itemize}
    \item First, most of the manufacturers do not provide a formal specification of their hardware -- which implies that in order to reason on hardware specification, one has to interpret the informal specification to produce a formal one. This process is tedious and error-prone.
    As a side-effect, it is delicate to verify software that directly rely on hardware primitives. Nonetheless, progress is made in that domain, notably with open hardware development and manufacturers beginning to provide such specifications \cite{reid2017guards}.
    \item Second -- assuming there were a formal specification of the hardware -- there are no known method to prove that the hardware effectively behaves as described by its specification.
\end{itemize}

As such, and in spite of the modern hardware's increasing complexity, running code on a specific hardware implicitly includes the whole hardware in the TCB.

\subsubsection{Inclusion of primitives and libraries inside the TCB}

We argued in Section \ref{sec:implementation} that the primitives we use in our election function are straightforward enough to trust \emph{without a doubt} that their implementation indeed conforms to their specification. There are however two primitives that are arguably too big to reach such a claim : a sorted insertion primitive and a primitive that applies a modification to every element of a list.

The main reason behind our choice of interface is that the core of our contribution is the election function correctness proof. We deemed that the memory management aspect of this work was orthogonal to the properties we proved. Considering the reasonable size (respectively thirteen and seven lines of C) of the impacted primitives, we decided to treat them as trusted libraries -- like the oracles -- and not to embed them further into the model.

However, in a setting where every single piece of code has to be proved (for example in a case where the proofs relies on a formal specification of the hardware), one could imagine to apply our methodology to get rid of these two primitives. The process would follow what we described in the previous sections. The first step would be to design an interface that further decomposes the two primitives, then write a monadic program that exclusively uses the broken down primitives, and finally prove that this new monadic program refines the original one.

As a side note, we want to reflect on the discussion we had in this section about our interface choices. We believe our proof methodology, and particularly the use of shallow embedding, sheds light on the assumptions brought by the Trusted Computing Base and presses us to discuss these choices. Specifically, because proof and implementation are expressed in the same language, they both share the same definition of TCB assumptions, which we believe is strongly beneficial to the proof process. In comparison, it seems straightforward to us that proofs conducted on deep embedding structures -- that represents the implementation language in the proof assistant -- adds a layer of obfuscation on the Trusted Computing Base.


		\textcolor{red}{Résumer les claims et introduire la contribution suivante}
