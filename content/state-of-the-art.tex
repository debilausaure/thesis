\chapter{État de l'art (20-30 pages)}

	Ce chapitre a pour intention de définir et préciser les différentes notions nécessaires à la lecture des travaux de thèses, ainsi que de définir le contexte scientifique du travail. Il portera, dans une première section, sur les détails des différents transferts de flot d'exécution dans les systèmes modernes, ainsi que les changements d'états inhérents à ces transferts de flot d'exécution. Cette section abordera ensuite les problèmes de sécurité liés au transfert de flot d'exécution, ainsi que les techniques de mitigation de ces problèmes. Cette section terminera sur les problématiques temps réel touchant au transfert de flot d'exécution.
	La seconde section de ce chapitre fera un état des lieux de la preuve de programme. Elle commencera par discuter de ce qu'est une preuve et de leur vérificaton automatique, ainsi que des stratégies de conduite de preuve. Cette section continuera sur la preuve de programme, en particulier comment raisonner sur un programme impératif. Elle abordera aussi les notions de représentation du langage. Enfin, elle terminera sur les exemples de systèmes vérifiés formellement.

	\section{Transfert de flôt d'exécution}

		Cette section va détailler les différents transferts de flot d'exécution mis à disposition dans les cpus modernes.
		Dans cette section, nous détaillerons les transferts de flot d'exécution qui impliquent une reconfiguration explicite de l'état de la machine ayant un impact sur les droits d'accès aux ressources. Les appels d'une fonction d'un programme vers une autre fonction ne seront pas considérés dans cette section, même s'ils pourraient être considérés comme un transfert de flôt d'exécution. 


		\subsection{Hardware}

			\subsubsection{Appels explicites}
			Les transferts les plus courants sont les transferts de flot d'exécution explicites, c'est-à-dire dont la cible est explicitement fournie lors de l’appel, ou clairement établie dans la documentation.

Par exemple, dans Linux, un processus peut demander l’ouverture d’un fichier avec l’appel système open(). Cet appel transfère le flot d’exécution d’un processus non privilégié vers le noyau Linux disposant du plus haut niveau de privilèges. Les fonctions appelables par des transferts explicites servent d’interface entre des logiciels disposant de droits distincts.

Ce type de transfert de flôt d'exécution, d'apparence assez anodine, est pourtant l'objet d'attaques multiples, dont le but est de faire dévier l'exécution (de préférence en mode privilégié) vers du code choisi par l'attaquant.

Pour y arriver, un attaquant doit exploiter une vulnérabilité dans une portion de code, qui lui donnera le contrôle d'une zone de mémoire d'intérêt (la pile, le tas, ou même le code).

Une fois qu'il contrôle cette zone mémoire, il lui suffit d'écrire un \emph{shellcode}, et d'exploiter une vulnérabilité dans du code privilégié pour que l'exécution du \texttt{return} de la fonction compromise saute dans le shellcode. L'attaquant gagne à ce moment le contrôle de la machine.

Commence alors un jeu du chat et de la souris pour essayer de mitiger l'impact de ces vulnérabilités.

Pour compliquer la vie de l'attaquant, et qu'il lui soit plus difficile d'exécuter son shellcode, de nombreuses stratégies ont été entreprises par les fabriquant de matériels ainsi que par les développeurs de systèmes d'exploitation. 

\paragraph{Canaries}
Une première statégie est l'ajout de \emph{canary} qui visent à détecter les corruptions mémoires. Les canaries sont des valeurs écrites dans la pile ou le tas et qui sont générées aléatoirement à chaque exécution. Lors de la sortie de la frame protégée par le canary, le code vérifie que la valeur du canary correspond bien à celle qui avait été écrite initialement ; si ce n'est pas le cas, c'est qu'une corruption mémoire a eu lieu et une faute est levée.

Une des techniques permettant de vaincre les canaries est de lire la valeur initiale du canary avant de corrompre la mémoire. En effet, la canary \textbf{reste la même pour l'intégralité de l'exécution}. Une fois cette valeur récupérée, il suffit de corrompre la mémoire en réécrivant cette valeur au bon endroit pour échapper à la détection. De plus, si l'exploitation de la vulnérabilité permet de corrompre la mémoire de manière fine, il suffit d'éviter d'écrire sur la canary.

\paragraph{Droits fins pour les zones mémoires}

Une autre stratégie a été de définir des droits fins concernant l'accès aux différentes zones mémoires de l'espace d'adressage des processus. Le mécanisme de mémoire virtuelle permet de définir des droits d'accès propres à chaque page mémoire configurée (lecture, écriture, éxecution, accessible en mode non priviligié). Par exemple, les pages mémoire contenant du code sont typiquement configurées pour des accès en lecture et exécution, alors que les pages contenant des données (pour la pile, le tas, les sections de données d'un binaire) sont configurées pour des accès en lecture/écriture.

Cette stratégie de défense empêche un attaquant d'exploiter une vulnérabilité pour écrire un shellcode code dans la mémoire si on considère que chaque page de mémoire est soit exécutable, soit accessible en écriture. Cependant, il existe des cas d'usage légitimes qui violent cette contrainte, par exemple lors de compilation à la volée (ou JIT, pour Just-In-Time). Fatalement, de tels logiciels sont devenus la cible privilégiée des attaquants, on pourra par exemple citer Webkit.% https://github.com/saelo/cve-2018-4233
Heureusement, il est peu probable que de tels logiciels aient besoin de s'exécuter en mode privilégié. 

Pour affaiblir ce vecteur d'attaque, cette stratégie de défense est renforcée par des mécanismes de sécurité supplémentaires tels que le \emph{Supervisor Mode Access Prevention} (SMAP) et le \emph{Supervisor Mode Execution Prevention} (SMEP). SMAP permet au processeur de lever une faute lorsque qu'il exécute du code privilégié et qu'il essaie d'accéder (en lecture ou en écriture) à des données présentes dans l'espace utilisateur. SMEP permet en complément de lever une faute lorsque le processeur essaie d'exécuter du code dans l'espace utilisateur alors qu'il se trouve dans un mode d'exécution privilégié.

Ces mécanismes permettent d'isoler le code privilégié de potentiels shellcodes écrit en espace utilisateur. Ainsi, pour compromettre intégralement un système, l'attaquant doit à présent exploiter une vulnérabilité dans le code privilégié, ayant à sa disposition des pages mémoire soit accessibles en écriture soit exécutables et qui, de surcrois, ne font pas partie de l'espace utilisateur.
Nait alors une nouvelle technique d'exploitation de vulnérabilité. 

\paragraph{Return Oriented Programming}
Le ROP (pour \emph{Return Oriented Programming}) consiste à attaquer du code vulnérable en n'utilisant que le code déjà accessible dans l'environnement d'origine, mais en exécutant des portions arbitraires de celui-ci. L'attaque consiste à repérer des \emph{gadgets} : de brèves portions de code ayant un effet spécifique sur la mémoire ou les registres, suivi d'une instruction \texttt{return}. Pour l'attaquant, il suffit de dévier le flot d'exécution sur l'un de ces gadgets et de manipuler la mémoire, de manière à ce que l'exécution du gadget entraine l'exécution du suivant. L'attaquant parvient au final à exécuter son shellcode constitué d'une succession de gadgets.\\

Plusieurs contre-mesures ont émergé pour rendre plus difficile le ROP.

\paragraph{Address Space Layout Randomization}
L'ASLR (pour \emph{Address Space Layout Randomization}) rend imprédictible l'adresse des différentes zones de mémoire au sein d'un espace d'adressage virtuel. Les adresses du binaire, de la pile, du tas, des librairies, du noyau, etc. sont rendus aléatoires à chaque nouvelle exécution. L'ASLR est un de ce fait un frein considérable au développement d'un shellcode en ROP, puisqu'il est impossible de prédire où se situeront les gadgets lors de la prochaine exécution.

L'ASLR n'est cependant pas parfait. Les adresses des différentes zones mémoire peuvent être révélées par des pointeurs vers des objets contenus dans d'autres zones, %https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#bypassing-kaslrsmep
ou grâce à des attaques micro-architecturales % Prefetch Side-Channel Attacks: Bypassing SMAP and Kernel ASLR. In: CCS’16 (2016) && Practical Timing Side Channel Attacks against Kernel Space ASLR. In: S&P’13 (2013)

\paragraph{Vérification de l'intégrité du flôt d'exécution}

Une autre approche permettant de réduire la marge de manoeuvre de l'attaquant et de vérifier que le flot d'exécution est conforme à celui attendu. À chaque appel et à chaque retour de fonction, le processeur vérifie si la cible du saut est valide. Plusieurs implémentations existent, notamment au sein du matériel processeurs et des compilateurs. Windows, macOS, Android, iOS utilisent déjà une mécanisme de vérification du flot d'exécution.
% https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/armv8-1-m-pointer-authentication-and-branch-target-identification-extension
% https://www.intel.com/content/dam/develop/external/us/en/documents/catc17-introduction-intel-cet-844137.pdf
% https://clang.llvm.org/docs/ControlFlowIntegrity.html


\paragraph{eXecute Only Memory}

Le XOM (pour \emph{eXecute Only Memory}), est une fonctionnalité de certain processeurs permettant de déclencher une faute lorsque qu'un accès en lecture est fait sur les pages mémoires configurées comme étant exécutables. Avant cette fonctionnalité, aucune distinction n'était faite entre le processus de récupération des instructions par le processeur et la lecture de données par l'utilisateur. Cette fonctionnalité rend considérablement pour difficile la recherche de gadgets, puisqu'il est impossible pour l'attaquant de lire le code qu'il souhaite compromettre directement sur la cible.
On pourrait argumenter que cette fonctionnalité relève de la sécurité par l'obscurité, et qu'elle n'est pas réellement efficace. 


Ce type de transfert de flot d’exécution est l’objet d’attaques multiples, car c’est lui qui octroie au logiciel appelé des droits supérieurs aux droits de l’appelant. Parvenir à déclencher un tel appel sur un code arbitraire suffit donc au contournement des barrières matérielles de sécurité.

Pour pallier ces attaques, de nombreuses méthodes permettant de détecter et de corriger les vulnérabilités classiques (telles que les dépassements de tableau) ont vu le jour. On pourrait citer les méthodes d’analyse statique, les méthodes d’exécution symbolique, de fuzzing, et plus particulièrement le langage Rust conçu pour éradiquer ces vulnérabilités par conception. Par ailleurs, des travaux ont été entamés pour prouver formellement les fonctionnalités de Rust.

			\subsubsection{Interruptions matérielles}

			

			\subsubsection{Fautes}


		\subsection{Software}

			\subsubsection{Capture de l'état d'exécution}

			\subsubsection{Changement de droits}

				Espace d'adressage, niveau de privilèges

		\subsection{Failles de sécurités associées}
			%https://google.github.io/security-research/pocs/linux/bleedingtooth/writeup.html#achieving-rip-control
			%https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html
			%https://github.com/Bonfee/CVE-2022-0995
			CVE historiques ? :D

			%https://pointer-authentication.github.io/

		\subsection{Ordonnancement}

			\subsubsection{Partage équitable du CPU}

			\subsubsection{Respect des contraintes de temps}

	\section{Preuve de code}

		\subsection{Vérification automatique d'une preuve}

			\subsubsection{Qu'est ce qu'une preuve ?}

				\paragraph{Axiomes}
				\paragraph{Hypothèses}
				\paragraph{Raisonnement}

			\subsubsection{Exemple de Coq}

			\subsubsection{Stratégie de conduite / vérification de preuve}

				\paragraph{Preuve directe}
				\paragraph{Preuve par raffinement}

		\subsection{Preuve de programme}

			\subsubsection{Raisonner sur un programme impératif}

				\paragraph{preconditions}

				\paragraph{règles de transition} (sémantique opérationnelle)

				\paragraph{postconditions} (Hoare, logique de séparation)

			\subsubsection{Langage}

				\paragraph{Représentation du programme} (deep/shallow)

				\paragraph{Monade}

		\subsection{Illustration système}

			\subsubsection{SeL4}
			\subsubsection{CertikOS}
			\subsubsection{Pip}
